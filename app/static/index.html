<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>젬미나이</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-1: #0a1422;
      --bg-2: #1d2f44;
      --card: #0f1f2f;
      --line: #2f516f;
      --line-soft: #23415b;
      --accent-gold: #ffd166;
      --accent-cyan: #6ee7f7;
      --accent-green: #89f59d;
      --accent-red: #ff8b8b;
      --text-main: #eef5ff;
      --text-sub: #b9c9dc;

      /* category colors (from gem_prog.py) */
      --stat-will: #ff5a3c;
      --stat-point: #f5c542;
      --stat-eff1: #6bff4a;
      --stat-eff2: #4fd6ff;
      --stat-special: #aaaaaa;
    }

    body {
      font-family: "Exo 2", sans-serif;
      color: var(--text-main);
      background:
        radial-gradient(circle at 8% 12%, rgba(110, 231, 247, 0.16), transparent 30%),
        radial-gradient(circle at 92% 82%, rgba(255, 209, 102, 0.12), transparent 34%),
        linear-gradient(130deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    .panel {
      background: linear-gradient(170deg, rgba(15, 31, 47, 0.93), rgba(10, 21, 35, 0.9));
      border: 1px solid var(--line);
      box-shadow: 0 12px 36px rgba(1, 9, 17, 0.36);
      border-radius: 1rem;
    }

    .halo {
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 0 40px rgba(110, 231, 247, 0.08);
      border-radius: 1rem;
    }

    .glow-btn {
      transition: transform 140ms ease, box-shadow 140ms ease, opacity 140ms ease;
    }

    .glow-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 22px rgba(110, 231, 247, 0.26);
    }

    .glow-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

	    .diamond-shell {
	      --dia-border: var(--line-soft);
	      --dia-accent: var(--accent-cyan);
	      --dia-tint: rgba(110, 231, 247, 0.12);
		      width: clamp(7.25rem, 15vw, 9.5rem);
		      height: clamp(7.25rem, 15vw, 9.5rem);
		      transform: rotate(45deg);
		      border: 1px solid var(--dia-border);
		      border-radius: 1.25rem;
      background:
        radial-gradient(circle at 18% 18%, var(--dia-tint), transparent 62%),
        linear-gradient(140deg, rgba(32, 53, 73, 0.84), rgba(12, 26, 40, 0.9));
      box-shadow: inset 0 0 34px var(--dia-tint);
	      overflow: hidden;
	    }

		    .diamond-stage {
		      width: clamp(19rem, 42vw, 26rem);
		      height: clamp(19rem, 42vw, 26rem);
		    }

    .diamond-shell .stat-name {
      color: var(--dia-accent);
    }

    .diamond-shell .mini-control {
      border-color: var(--dia-border);
    }

    .diamond-shell .stat-input {
      border-color: var(--dia-border);
    }

    .diamond-will {
      --dia-border: rgba(255, 90, 60, 0.55);
      --dia-accent: var(--stat-will);
      --dia-tint: rgba(255, 90, 60, 0.14);
    }

    .diamond-point {
      --dia-border: rgba(245, 197, 66, 0.55);
      --dia-accent: var(--stat-point);
      --dia-tint: rgba(245, 197, 66, 0.12);
    }

    .diamond-eff1 {
      --dia-border: rgba(107, 255, 74, 0.55);
      --dia-accent: var(--stat-eff1);
      --dia-tint: rgba(107, 255, 74, 0.12);
    }

    .diamond-eff2 {
      --dia-border: rgba(79, 214, 255, 0.55);
      --dia-accent: var(--stat-eff2);
      --dia-tint: rgba(79, 214, 255, 0.12);
    }

	    .diamond-inner {
	      width: 100%;
	      height: 100%;
	      transform: rotate(-45deg);
	      display: flex;
	      flex-direction: column;
	      align-items: center;
	      justify-content: center;
	      gap: 0.3rem;
	      padding: 0.3rem clamp(0.5rem, 1.8vw, 0.8rem);
	    }

	    .mini-control {
	      width: clamp(1.1rem, 3.8vw, 1.45rem);
	      height: clamp(1.1rem, 3.8vw, 1.45rem);
	      border-radius: 0.4rem;
	      border: 1px solid #446b8c;
	      color: #d8ecff;
	      background: rgba(36, 60, 80, 0.9);
      font-weight: 700;
      line-height: 1;
    }

    .stat-input {
      width: clamp(1.85rem, 4.6vw, 2.3rem);
      border-radius: 0.45rem;
      border: 1px solid #3f5f7d;
      background: rgba(11, 24, 37, 0.9);
      color: #dff2ff;
      text-align: center;
      font-weight: 700;
    }

    .selector-card {
      border: 1px solid rgba(101, 168, 218, 0.45);
      border-radius: 0.65rem;
      background: linear-gradient(160deg, rgba(20, 44, 67, 0.82), rgba(12, 26, 43, 0.86));
      padding: 0.55rem 0.65rem;
    }

    .selector-select {
      width: 100%;
      border-radius: 0.5rem;
      border: 1px solid #3f5f7d;
      background: rgba(11, 24, 37, 0.95);
      color: #dff2ff;
      font-weight: 600;
      font-size: 0.82rem;
      padding: 0.35rem 0.45rem;
      outline: none;
    }

    /* Hide number input spinners (we use +/- buttons instead). */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    .option-card {
      --opt-border: #2b4c68;
      --opt-hover: #64d8ee;
      --opt-glow: rgba(110, 231, 247, 0.2);
      --opt-tint: rgba(110, 231, 247, 0.12);
      border: 1px solid var(--opt-border);
      background:
        radial-gradient(circle at 18% 18%, var(--opt-tint), transparent 62%),
        linear-gradient(160deg, rgba(20, 44, 67, 0.9), rgba(12, 26, 43, 0.92));
      color: #dcefff;
      border-radius: 0.9rem;
      min-height: 4.35rem;
      transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
    }

    .option-card:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: var(--opt-hover);
      box-shadow: 0 7px 18px var(--opt-glow);
    }

    .option-card:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .option-slot {
      position: relative;
    }

    .option-slot.is-selected {
      box-shadow: 0 0 0 2px rgba(110, 231, 247, 0.28), 0 10px 24px rgba(110, 231, 247, 0.12);
    }

    .option-slot.is-drop-hover {
      border-color: rgba(110, 231, 247, 0.75);
      box-shadow: 0 0 0 2px rgba(110, 231, 247, 0.22), 0 12px 26px rgba(110, 231, 247, 0.12);
    }

    .option-slot-empty {
      opacity: 0.55;
      border-style: dashed;
    }

    .option-slot-clear {
      position: absolute;
      top: 0.35rem;
      right: 0.35rem;
      width: 1.6rem;
      height: 1.6rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: rgba(2, 6, 23, 0.55);
      color: rgba(226, 232, 240, 0.92);
      font-weight: 900;
      line-height: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 140ms ease, border-color 140ms ease, opacity 140ms ease;
    }

    .option-slot-clear:hover {
      transform: translateY(-1px);
      border-color: rgba(110, 231, 247, 0.55);
    }

    .option-slot-clear:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    .option-choice {
      min-height: 3.25rem;
      cursor: grab;
    }

    .option-choice:active {
      cursor: grabbing;
    }

    .option-choice:disabled {
      opacity: 0.32;
      border-style: dashed;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .opt-will {
      --opt-border: rgba(255, 90, 60, 0.45);
      --opt-hover: var(--stat-will);
      --opt-glow: rgba(255, 90, 60, 0.22);
      --opt-tint: rgba(255, 90, 60, 0.16);
    }

    .opt-point {
      --opt-border: rgba(245, 197, 66, 0.45);
      --opt-hover: var(--stat-point);
      --opt-glow: rgba(245, 197, 66, 0.22);
      --opt-tint: rgba(245, 197, 66, 0.14);
    }

    .opt-eff1 {
      --opt-border: rgba(107, 255, 74, 0.45);
      --opt-hover: var(--stat-eff1);
      --opt-glow: rgba(107, 255, 74, 0.22);
      --opt-tint: rgba(107, 255, 74, 0.14);
    }

    .opt-eff2 {
      --opt-border: rgba(79, 214, 255, 0.45);
      --opt-hover: var(--stat-eff2);
      --opt-glow: rgba(79, 214, 255, 0.22);
      --opt-tint: rgba(79, 214, 255, 0.14);
    }

    .opt-special {
      --opt-border: rgba(170, 170, 170, 0.35);
      --opt-hover: var(--stat-special);
      --opt-glow: rgba(170, 170, 170, 0.2);
      --opt-tint: rgba(170, 170, 170, 0.12);
    }
  </style>
</head>
<body>
  <main class="mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
    <header class="panel p-4 sm:p-5">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <div>
          <h1 class="text-2xl font-extrabold tracking-tight text-sky-100">젬미나이</h1>
          <p class="mt-1 text-sm text-slate-300">게임 창을 공유한 뒤 <span class="font-semibold text-cyan-300">젬미나이</span>를 누르면 추천 행동이 표시됩니다. 가공 후 옵션을 선택해주세요.</p>
        </div>
        <div class="flex flex-wrap gap-2">
          <button id="shareStartBtn" class="glow-btn rounded-lg border border-cyan-400/50 bg-cyan-400/15 px-4 py-2 text-sm font-semibold text-cyan-100">
            화면 공유 시작
          </button>
          <button id="shareStopBtn" class="glow-btn rounded-lg border border-slate-500/60 bg-slate-500/15 px-4 py-2 text-sm font-semibold text-slate-200" disabled>
            공유 중지
          </button>
        </div>
      </div>
      <div class="mt-3 flex flex-wrap items-center gap-x-6 gap-y-2 text-sm">
        <div>
          서버 상태:
          <span id="serverStatus" class="ml-1 font-semibold text-slate-200">확인 중</span>
        </div>
      </div>
    </header>

    <section class="mt-5 grid gap-4 lg:grid-cols-[1.1fr_1fr]">
      <div class="panel p-4">
        <div class="flex items-center justify-between gap-3">
          <h2 class="text-lg font-bold text-sky-100">공유 화면</h2>
          <div class="flex items-center gap-2">
            <button
              id="roiAdjustBtn"
              class="glow-btn rounded-md border border-slate-500/60 bg-slate-500/10 px-3 py-1.5 text-xs font-semibold text-slate-100"
              disabled
            >
              화면 조정
            </button>
            <div class="relative group">
              <button
                type="button"
                class="glow-btn flex h-7 w-7 items-center justify-center rounded-full border border-slate-500/60 bg-slate-500/10 text-xs font-extrabold text-slate-100"
                aria-label="화면 조정 도움말"
              >
                ?
              </button>
              <div
                class="pointer-events-none absolute right-0 top-full z-10 mt-2 hidden w-max max-w-xs rounded-md border border-slate-700 bg-slate-950/95 px-3 py-2 text-xs text-slate-200 shadow-lg group-hover:block"
              >
                화면 인식할 부분을 조정합니다
              </div>
            </div>
          </div>
        </div>
        <p class="mt-1 text-xs text-slate-300">공유화면 아래 설정에 게임 창을 선택해주세요.</p>
        <div class="halo mt-3 p-3">
          <video id="screenVideo" class="h-[18rem] w-full rounded-xl border border-slate-700/80 bg-slate-950 object-contain sm:h-[22rem]" autoplay muted playsinline></video>
        </div>
        <div class="mt-4 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
          <div class="text-sm font-semibold text-sky-100">버그 제보하기</div>
          <p class="mt-1 text-xs text-slate-300">버그 제보시 버그 수정을 위해 이미지와 AI 결과가 서버에 저장됩니다.</p>
          <textarea
            id="bugReportInput"
            class="mt-2 h-24 w-full rounded-md border border-slate-700 bg-slate-950/85 px-3 py-2 text-sm text-slate-100 outline-none focus:border-cyan-400/70"
            placeholder="예: 리롤 2회인데 3회로 표시됩니다."
          ></textarea>
          <div class="mt-2 flex items-center justify-between gap-2">
            <button
              id="bugReportSendBtn"
              class="glow-btn rounded-lg border border-cyan-400/60 bg-cyan-400/15 px-3 py-2 text-xs font-semibold text-cyan-100"
            >
              보내기
            </button>
            <div id="bugReportStatus" class="hidden text-xs"></div>
          </div>
        </div>

		        <div class="mt-3 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
		          <div class="text-sm font-semibold text-sky-100">공지사항</div>
		          <ul id="noticeList" class="mt-2 space-y-1 text-xs text-slate-300">
		            <li>공지사항을 불러오는 중입니다...</li>
		          </ul>
		        </div>

	      </div>

      <div class="panel p-4">
        <div class="flex flex-wrap items-center justify-between gap-3">
          <h2 class="text-lg font-bold text-sky-100">젬 상태</h2>
          <div class="text-sm text-slate-300">
            현재 합계: <span id="currentSum" class="font-bold text-cyan-200">4</span> /
            목표 합계: <span id="targetSum" class="font-bold text-amber-200">16</span>
          </div>
        </div>
        <p class="mt-1 text-xs text-slate-300">실제 게임에서 적용된 옵션을 눌러 현재 스탯에 반영하세요.</p>

        <div class="mt-3 grid gap-2 sm:grid-cols-2">
          <label class="selector-card">
            <div class="text-[11px] font-semibold uppercase tracking-wide text-slate-300">역할</div>
            <select id="roleSelect" class="selector-select mt-1">
              <option value="dealer">딜러</option>
              <option value="support">서폿</option>
            </select>
          </label>
          <label class="selector-card">
            <div class="text-[11px] font-semibold uppercase tracking-wide text-slate-300">젬 종류</div>
            <select id="gemTypeSelect" class="selector-select mt-1">
              <option value="stable">안정/침식</option>
              <option value="solid">견고/왜곡</option>
              <option value="immutable">불변/붕괴</option>
            </select>
          </label>
        </div>

        <div class="halo mt-3 p-3 sm:p-4">
			          <div class="diamond-stage relative mx-auto max-w-full">
		            <div class="absolute left-1/2 top-5 -translate-x-1/2">
	              <div class="diamond-shell diamond-will">
	                <div class="diamond-inner" data-stat="willpower">
                  <div class="stat-name text-xs font-semibold">의지력</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="willpower">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="willpower" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="willpower">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="willpower">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="willpower" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="willpower">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute left-5 top-1/2 -translate-y-1/2">
	              <div class="diamond-shell diamond-eff1">
	                <div class="diamond-inner" data-stat="effect1_level">
                  <div class="stat-name text-xs font-semibold">부옵션1</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="effect1_level">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="effect1_level" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="effect1_level">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="effect1_level">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="effect1_level" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="effect1_level">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute right-5 top-1/2 -translate-y-1/2">
	              <div class="diamond-shell diamond-eff2">
	                <div class="diamond-inner" data-stat="effect2_level">
                  <div class="stat-name text-xs font-semibold">부옵션2</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="effect2_level">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="effect2_level" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="effect2_level">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="effect2_level">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="effect2_level" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="effect2_level">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute bottom-5 left-1/2 -translate-x-1/2">
              <div class="diamond-shell diamond-point">
                <div class="diamond-inner" data-stat="points">
                  <div class="stat-name text-xs font-semibold">질서/혼돈</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="points">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="points" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="points">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="points">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="points" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="points">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>
          </div>
        </div>

	        <div class="mt-4 grid grid-cols-2 gap-2 sm:grid-cols-3">
	          <button id="resetBtn" class="glow-btn rounded-lg border border-rose-400/60 bg-rose-400/15 px-4 py-3 text-sm font-bold text-rose-100">
	            초기화
	          </button>
            <button id="optionPickerBtn" class="glow-btn rounded-lg border border-slate-500/60 bg-slate-500/10 px-4 py-3 text-sm font-bold text-slate-100">
              옵션 선택
            </button>
	          <button id="analyzeBtn" class="glow-btn col-span-2 rounded-lg border border-amber-300/60 bg-amber-300/20 px-4 py-3 text-sm font-bold text-amber-100 sm:col-span-1" disabled>
	            젬미나이
	          </button>
	        </div>

	        <div id="analyzeError" class="mt-2 hidden rounded-lg border border-rose-400/40 bg-rose-400/10 px-3 py-2 text-xs text-rose-100"></div>

	        <div id="optionsGrid" class="mt-2 grid grid-cols-2 gap-2 sm:grid-cols-4"></div>

        <div class="mt-4 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
          <div class="text-xs font-semibold uppercase tracking-wide text-slate-400">추천 행동</div>
          <div id="actionCard" class="mt-2 grid grid-cols-1 overflow-hidden rounded-md border border-slate-700 bg-slate-950/85">
            <div class="px-3 py-3 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">추천</div>
              <div id="actionText" class="mt-1 text-lg font-extrabold text-slate-200">-</div>
            </div>
            <div class="border-t border-slate-800/80 px-3 py-3 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">성공 확률</div>
              <div id="successProbText" class="mt-1 text-lg font-extrabold text-rose-200">-</div>
            </div>
          </div>
	          <div class="mt-3 grid grid-cols-3 gap-2">
	            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
	              <div class="text-[11px] uppercase tracking-wide text-slate-400">리롤</div>
	              <div class="mt-1 flex items-center justify-center gap-2">
	                <button class="mini-control" data-adjust="rerolls" data-delta="-1">-</button>
	                <div id="rerollsText" class="min-w-[2ch] text-lg font-bold text-slate-100">-</div>
	                <button class="mini-control" data-adjust="rerolls" data-delta="1">+</button>
	              </div>
	            </div>
	            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
	              <div class="text-[11px] uppercase tracking-wide text-slate-400">가공횟수</div>
	              <div class="mt-1 flex items-center justify-center gap-2">
	                <button class="mini-control" data-adjust="attempts_left" data-delta="-1">-</button>
	                <div id="countText" class="min-w-[2ch] text-lg font-bold text-slate-100">-</div>
	                <button class="mini-control" data-adjust="attempts_left" data-delta="1">+</button>
	              </div>
	            </div>
	            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
	              <div class="text-[11px] uppercase tracking-wide text-slate-400">가공비용</div>
	              <div class="mt-1 flex items-center justify-center gap-2">
	                <button class="mini-control" data-adjust="cost_state" data-delta="-1">-</button>
	                <div id="costText" class="min-w-[5ch] text-lg font-bold text-slate-100">-</div>
	                <button class="mini-control" data-adjust="cost_state" data-delta="1">+</button>
	              </div>
	            </div>
	          </div>
	        </div>
      </div>
    </section>
  </main>

  <div id="roiAdjustModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 p-4">
    <div class="panel w-full max-w-6xl p-4 sm:p-5">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <div>
          <div class="text-lg font-extrabold tracking-tight text-sky-100">화면 조정</div>
          <div class="mt-1 text-xs text-slate-300">박스를 드래그해서 화면 인식 위치를 맞춘 뒤 적용을 누르세요.</div>
        </div>
        <div class="flex items-center gap-2">
          <button
            id="roiAdjustCancelBtn"
            class="glow-btn rounded-lg border border-slate-500/60 bg-slate-500/10 px-4 py-2 text-sm font-semibold text-slate-100"
          >
            취소
          </button>
          <button
            id="roiAdjustApplyBtn"
            class="glow-btn rounded-lg border border-cyan-400/60 bg-cyan-400/15 px-4 py-2 text-sm font-semibold text-cyan-100"
          >
            적용
          </button>
        </div>
      </div>

      <div class="mt-4 grid gap-3 lg:grid-cols-[1fr_16rem]">
        <div id="roiAdjustPreviewWrap" class="relative h-[68vh] w-full overflow-hidden rounded-xl border border-slate-700/80 bg-slate-950">
          <img id="roiAdjustPreviewImg" class="absolute inset-0 h-full w-full object-contain" alt="ROI 미리보기" />
          <div id="roiAdjustOverlay" class="absolute inset-0">
            <div
              id="roiDragOptions"
              data-drag="options"
              class="group pointer-events-auto absolute touch-none rounded-md border-2 border-rose-400/90 bg-rose-400/5 shadow-[0_0_0_1px_rgba(0,0,0,0.3)] cursor-move"
            >
              <div class="pointer-events-none absolute -top-7 left-0 whitespace-nowrap rounded bg-slate-950/70 px-2 py-0.5 text-[11px] font-extrabold text-rose-200 opacity-0 transition-opacity duration-150 group-hover:opacity-100 group-active:opacity-100">옵션</div>
              <div id="roiOptSep1" class="absolute top-0 h-full w-[2px] bg-rose-400/70"></div>
              <div id="roiOptSep2" class="absolute top-0 h-full w-[2px] bg-rose-400/70"></div>
              <div id="roiOptSep3" class="absolute top-0 h-full w-[2px] bg-rose-400/70"></div>
            </div>

            <div
              id="roiDragReroll"
              data-drag="possible"
              class="group pointer-events-auto absolute touch-none rounded-md border-2 border-cyan-300/90 bg-cyan-300/5 shadow-[0_0_0_1px_rgba(0,0,0,0.3)] cursor-move"
            >
              <div class="pointer-events-none absolute -top-7 left-0 whitespace-nowrap rounded bg-slate-950/70 px-2 py-0.5 text-[11px] font-extrabold text-cyan-200 opacity-0 transition-opacity duration-150 group-hover:opacity-100 group-active:opacity-100">리롤</div>
            </div>

            <div
              id="roiDragCount"
              data-drag="count"
              class="group pointer-events-auto absolute touch-none rounded-md border-2 border-amber-300/90 bg-amber-300/5 shadow-[0_0_0_1px_rgba(0,0,0,0.3)] cursor-move"
            >
              <div class="pointer-events-none absolute -top-7 left-0 whitespace-nowrap rounded bg-slate-950/70 px-2 py-0.5 text-[11px] font-extrabold text-amber-200 opacity-0 transition-opacity duration-150 group-hover:opacity-100 group-active:opacity-100">가공횟수</div>
            </div>

            <div
              id="roiDragCost"
              data-drag="cost"
              class="group pointer-events-auto absolute touch-none rounded-md border-2 border-emerald-300/90 bg-emerald-300/5 shadow-[0_0_0_1px_rgba(0,0,0,0.3)] cursor-move"
            >
              <div class="pointer-events-none absolute -top-7 left-0 whitespace-nowrap rounded bg-slate-950/70 px-2 py-0.5 text-[11px] font-extrabold text-emerald-200 opacity-0 transition-opacity duration-150 group-hover:opacity-100 group-active:opacity-100">골드</div>
            </div>
          </div>
        </div>

        <div class="rounded-lg border border-slate-700/80 bg-slate-900/70 p-3 text-xs text-slate-200">
          <div class="text-sm font-semibold text-sky-100">조정 대상</div>
          <ul class="mt-2 list-disc pl-4 text-slate-300">
            <li>옵션: 4개 옵션 영역을 한 번에 이동합니다.</li>
            <li>리롤: 우측 상단 “n회 가능” 영역입니다.</li>
            <li>가공횟수: 하단 “(n/9)” 영역입니다.</li>
            <li>골드: 우측 하단 비용 숫자 영역입니다.</li>
          </ul>
          <div class="mt-3 text-[11px] text-slate-400">
            팁: 옵션 박스는 내부 선(4등분)으로 실제 옵션 칸과 정렬하세요.
          </div>
          <div class="mt-4 border-t border-slate-700/80 pt-3">
            <div class="text-sm font-semibold text-sky-100">예시 이미지</div>
            <div class="mt-1 text-[11px] text-slate-400">기본 16:9 기준 예시입니다. (클릭하면 크게 볼 수 있어요)</div>
            <div class="mt-2 grid gap-1 text-[11px] text-slate-300">
              <div class="flex items-center gap-2">
                <span class="h-2.5 w-2.5 rounded-sm bg-rose-400"></span>
                <span>옵션</span>
              </div>
              <div class="flex items-center gap-2">
                <span class="h-2.5 w-2.5 rounded-sm bg-cyan-300"></span>
                <span>리롤</span>
              </div>
              <div class="flex items-center gap-2">
                <span class="h-2.5 w-2.5 rounded-sm bg-amber-300"></span>
                <span>가공횟수</span>
              </div>
              <div class="flex items-center gap-2">
                <span class="h-2.5 w-2.5 rounded-sm bg-emerald-300"></span>
                <span>골드</span>
              </div>
            </div>
            <a href="/static/roi_example.jpg" target="_blank" rel="noreferrer">
              <img
                src="/static/roi_example.jpg"
                alt="ROI 예시"
                loading="lazy"
                class="mt-2 w-full rounded-md border border-slate-700/80"
              />
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="optionPickerModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 p-4">
    <div class="panel w-full max-w-6xl p-4 sm:p-5">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <div>
          <div class="text-lg font-extrabold tracking-tight text-sky-100">옵션 선택</div>
          <div class="mt-1 text-xs text-slate-300">
            팔레트에서 드래그해서 위 슬롯에 덮어씌우세요.
          </div>
        </div>
        <div class="flex items-center gap-2">
          <button
            id="optionPickerRestoreBtn"
            class="glow-btn rounded-lg border border-slate-500/60 bg-slate-500/10 px-3 py-2 text-xs font-semibold text-slate-100"
          >
            복원
          </button>
          <button
            id="optionPickerCloseBtn"
            class="glow-btn rounded-lg border border-cyan-400/60 bg-cyan-400/15 px-3 py-2 text-xs font-semibold text-cyan-100"
          >
            닫기
          </button>
        </div>
      </div>

      <div class="mt-4">
        <div class="text-[11px] font-semibold uppercase tracking-wide text-slate-400">현재 옵션(4칸)</div>
        <div id="optionPickerSlots" class="mt-2 grid grid-cols-2 gap-2 sm:grid-cols-4"></div>
      </div>

      <div class="mt-4 overflow-x-auto">
        <div id="optionPickerPaletteWrap" class="min-w-[56rem]"></div>
      </div>

      <div class="mt-3 text-[11px] text-slate-400">
        팁: 슬롯을 클릭해 선택한 뒤 옵션을 클릭해도 적용됩니다.
      </div>
    </div>
  </div>

  <script>
			    const shareStartBtn = document.getElementById("shareStartBtn");
			    const shareStopBtn = document.getElementById("shareStopBtn");
				    const analyzeBtn = document.getElementById("analyzeBtn");
				    const resetBtn = document.getElementById("resetBtn");
            const optionPickerBtn = document.getElementById("optionPickerBtn");
				    const screenVideo = document.getElementById("screenVideo");
				    const roiAdjustBtn = document.getElementById("roiAdjustBtn");
				    const roiAdjustModal = document.getElementById("roiAdjustModal");
				    const roiAdjustPreviewWrap = document.getElementById("roiAdjustPreviewWrap");
				    const roiAdjustPreviewImg = document.getElementById("roiAdjustPreviewImg");
				    const roiAdjustOverlay = document.getElementById("roiAdjustOverlay");
				    const roiAdjustCancelBtn = document.getElementById("roiAdjustCancelBtn");
				    const roiAdjustApplyBtn = document.getElementById("roiAdjustApplyBtn");
				    const roiDragOptions = document.getElementById("roiDragOptions");
				    const roiDragReroll = document.getElementById("roiDragReroll");
				    const roiDragCount = document.getElementById("roiDragCount");
				    const roiDragCost = document.getElementById("roiDragCost");
				    const roiOptSep1 = document.getElementById("roiOptSep1");
				    const roiOptSep2 = document.getElementById("roiOptSep2");
				    const roiOptSep3 = document.getElementById("roiOptSep3");
				    const bugReportInput = document.getElementById("bugReportInput");
				    const bugReportSendBtn = document.getElementById("bugReportSendBtn");
				    const bugReportStatus = document.getElementById("bugReportStatus");
				    const noticeList = document.getElementById("noticeList");
					    const analyzeError = document.getElementById("analyzeError");
		          const roleSelect = document.getElementById("roleSelect");
		          const gemTypeSelect = document.getElementById("gemTypeSelect");

    const serverStatus = document.getElementById("serverStatus");
    const actionText = document.getElementById("actionText");
    const successProbText = document.getElementById("successProbText");
    const rerollsText = document.getElementById("rerollsText");
    const countText = document.getElementById("countText");
    const costText = document.getElementById("costText");
    const optionsGrid = document.getElementById("optionsGrid");
    const optionPickerModal = document.getElementById("optionPickerModal");
    const optionPickerSlots = document.getElementById("optionPickerSlots");
    const optionPickerPaletteWrap = document.getElementById("optionPickerPaletteWrap");
    const optionPickerRestoreBtn = document.getElementById("optionPickerRestoreBtn");
    const optionPickerCloseBtn = document.getElementById("optionPickerCloseBtn");
				    const currentSumEl = document.getElementById("currentSum");
				    const targetSumEl = document.getElementById("targetSum");

	      const DEFAULT_NOTICE_ITEMS = [
	        "2026-02-19: 2월 중으로 젬미나이 서비스가 종료됩니다. 자세한 내용은 https://www.inven.co.kr/board/lostark/4821/109447 을 참고해주시면 감사드리겠습니다.",
	        "2026-02-15: 옵션 인식이 틀리면 '옵션 선택'에서 4칸을 드래그로 덮어씌워 수동 보정할 수 있습니다.",
	        "2026-02-14: 리롤/가공횟수/가공비용은 아래 +/- 버튼으로 수동 조정할 수 있습니다.",
	        "2026-02-14: 공유 화면 옆 '화면 조정'에서 인식 영역(옵션/리롤/가공횟수/골드)을 드래그로 조정할 수 있습니다.",
	      ];

	      const NOTICE_URL_REGEX = /(https?:\/\/[^\s]+)/g;

	      function appendNoticeTextWithLinks(targetEl, text) {
	        if (!targetEl) return;
	        const src = String(text || "").trim();
	        if (!src) return;
	        let last = 0;
	        src.replace(NOTICE_URL_REGEX, (url, offset) => {
	          const at = Number(offset) || 0;
	          if (at > last) {
	            targetEl.appendChild(document.createTextNode(src.slice(last, at)));
	          }
	          const a = document.createElement("a");
	          a.href = url;
	          a.target = "_blank";
	          a.rel = "noopener noreferrer";
	          a.className = "underline decoration-cyan-300/80 underline-offset-2 hover:text-cyan-200";
	          a.textContent = url;
	          targetEl.appendChild(a);
	          last = at + url.length;
	          return url;
	        });
	        if (last < src.length) {
	          targetEl.appendChild(document.createTextNode(src.slice(last)));
	        }
	      }

	      function renderNoticeItems(items) {
	        if (!noticeList) return;
	        noticeList.innerHTML = "";
	        const list = Array.isArray(items) ? items : [];
	        if (list.length === 0) {
	          const li = document.createElement("li");
	          li.textContent = "공지사항이 없습니다.";
	          noticeList.appendChild(li);
	          return;
	        }
	        for (const raw of list) {
	          const li = document.createElement("li");
	          appendNoticeTextWithLinks(li, raw);
	          noticeList.appendChild(li);
	        }
	      }

	      async function loadNotice() {
	        // Server-side notice so we can update without redeploying the frontend.
	        try {
	          const res = await fetch("/api/notice", { method: "GET", cache: "no-store" });
	          const body = await res.json().catch(() => ({}));
	          if (!res.ok || !body || body.ok !== true) return;
	          const items = Array.isArray(body.items) ? body.items : [];
	          if (items.length) renderNoticeItems(items);
	        } catch (_err) {
	          // Ignore notice failures.
	        }
	      }

      function setServerStatusBadge(ok) {
        if (!serverStatus) return;
        if (ok === true) {
          serverStatus.textContent = "서버 정상";
          serverStatus.className = "ml-1 font-semibold text-emerald-300";
          return;
        }
        if (ok === false) {
          serverStatus.textContent = "서버 점검중";
          serverStatus.className = "ml-1 font-semibold text-amber-300";
          return;
        }
        serverStatus.textContent = "확인 중";
        serverStatus.className = "ml-1 font-semibold text-slate-200";
      }

      async function refreshServerStatus() {
        setServerStatusBadge(null);
        const health = await checkBackendHealthy();
        setServerStatusBadge(Boolean(health.ok));
        return health;
      }

		        function makeDefaultUiState(overrides = {}) {
		          return {
	            rerolls: 0,
	            attempts_left: 0,
            cost_state: 0,
            options: [],
            role: "dealer",
            gem_type: "stable",
            ...overrides,
          };
        }

				    const state = {
				      stream: null,
	            clientId: null,
			      current: {
			        willpower: 1,
			        points: 1,
			        effect1_level: 1,
			        effect2_level: 1,
		      },
			      target: {
			        willpower: 4,
			        points: 4,
			        effect1_level: 4,
			        effect2_level: 4,
			      },
			      uiState: makeDefaultUiState(),
	          uiOverride: {
	            rerolls: false,
	            attempts_left: false,
	            cost_state: false,
              options: false,
	          },
            optionOverrides: {},
            roiOverrides: null,
			      ocrCount: null,
				      lastResponse: null,
					      successProb: null,
					      lastError: null,
					    };

          const CLIENT_ID_STORAGE_KEY = "gemmini_client_id";

          function getOrCreateClientId() {
            try {
              const existing = String(window.localStorage.getItem(CLIENT_ID_STORAGE_KEY) || "").trim();
              if (existing && /^[0-9A-Za-z._-]{6,80}$/.test(existing)) {
                return existing;
              }
              const raw =
                (globalThis.crypto && typeof globalThis.crypto.randomUUID === "function"
                  ? globalThis.crypto.randomUUID()
                  : `${Date.now()}_${Math.random().toString(16).slice(2)}`) || "";
              const sanitized = raw.replace(/[^0-9A-Za-z._-]+/g, "_").replace(/^[_\\.]+|[_\\.]+$/g, "").slice(0, 64);
              const finalId = sanitized || `c_${Math.random().toString(16).slice(2, 10)}`;
              window.localStorage.setItem(CLIENT_ID_STORAGE_KEY, finalId);
              return finalId;
            } catch (_err) {
              return null;
            }
          }

          state.clientId = getOrCreateClientId();

			    function resetGemState() {
			      state.current = {
			        willpower: 1,
			        points: 1,
			        effect1_level: 1,
			        effect2_level: 1,
			      };
			      state.uiState = makeDefaultUiState({
	            role: state.uiState?.role || "dealer",
	            gem_type: state.uiState?.gem_type || "stable",
	          });
	          state.uiOverride = {
	            rerolls: false,
	            attempts_left: false,
	            cost_state: false,
              options: false,
	          };
            state.optionOverrides = {};
			      state.ocrCount = null;
				      state.lastResponse = null;
				      state.successProb = null;
			      state.lastError = null;
			      renderAll();
			    }

	    function clampStat(v) {
	      const n = Number(v);
	      if (!Number.isFinite(n)) return 1;
	      return Math.max(1, Math.min(5, Math.round(n)));
	    }

    function asInt(v, fallback = 0) {
      const n = Number(v);
      return Number.isFinite(n) ? Math.trunc(n) : fallback;
    }

	    function costFromState(costState) {
	      if (costState <= -1) return 0;
	      if (costState === 0) return 900;
	      if (costState >= 1) return 1800;
	      return 900;
	    }

	    function clampIntRange(v, lo, hi) {
	      const n = asInt(v, lo);
	      return Math.max(lo, Math.min(hi, n));
	    }

	    function adjustSummaryValue(field, delta) {
	      if (!state.uiState || !state.uiOverride) return;
	      const d = asInt(delta, 0);
	      if (!d) return;

	      if (field === "rerolls") {
	        const next = clampIntRange(asInt(state.uiState.rerolls, 0) + d, 0, 5);
	        state.uiState.rerolls = next;
	        state.uiOverride.rerolls = true;
	      } else if (field === "attempts_left") {
	        const next = clampIntRange(asInt(state.uiState.attempts_left, 0) + d, 0, 9);
	        state.uiState.attempts_left = next;
	        state.uiOverride.attempts_left = true;
	        // Prefer the manual integer display over OCR ratio text once user edits.
	        state.ocrCount = null;
	      } else if (field === "cost_state") {
	        const next = clampIntRange(asInt(state.uiState.cost_state, 0) + d, -1, 1);
	        state.uiState.cost_state = next;
	        state.uiOverride.cost_state = true;
	      } else {
	        return;
	      }

	      renderAll();
	    }

	    function bindSummaryAdjustControls() {
	      document.querySelectorAll("button[data-adjust]").forEach((btn) => {
	        if (btn.dataset.bound === "1") return;
	        btn.dataset.bound = "1";
	        btn.addEventListener("click", () => {
	          const field = String(btn.dataset.adjust || "");
	          const delta = asInt(btn.dataset.delta, 0);
	          adjustSummaryValue(field, delta);
	        });
	      });
	    }

	    function actionKo(actionName) {
	      if (!actionName) return "-";
	      const map = {
	        process: "가공",
        reroll: "리롤",
        stop: "가공 중단",
      };
      return map[actionName] || actionName;
    }

    function textOfOption(opt) {
      if (!opt) return "옵션 없음";
      return String(opt.text || opt.formatted || opt.option || opt.raw_option || "옵션 없음");
    }

    function escapeHtml(text) {
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function optionBlob(opt) {
      return [
        opt?.text || "",
        opt?.formatted || "",
        opt?.raw_option || "",
        opt?.option || "",
      ].join(" ").toLowerCase();
    }

    function isRerollOption(opt) {
      const blob = optionBlob(opt);
      return (
        blob.includes("reroll") ||
        blob.includes("다른 항목") ||
        blob.includes("항목 보기") ||
        blob.includes("새로고침") ||
        blob.includes("세로고침")
      );
    }

    function isCostOption(opt) {
      const blob = optionBlob(opt);
      return blob.includes("cost") || blob.includes("비용");
    }

    function renderStatInputs() {
      document.querySelectorAll("input[data-input='current']").forEach((el) => {
        const key = el.dataset.key;
        el.value = String(state.current[key]);
      });
      document.querySelectorAll("input[data-input='target']").forEach((el) => {
        const key = el.dataset.key;
        el.value = String(state.target[key]);
      });
    }

	    function renderSums() {
	      const currentSum = Object.values(state.current).reduce((acc, v) => acc + asInt(v, 1), 0);
	      const targetSum = Object.values(state.target).reduce((acc, v) => acc + asInt(v, 4), 0);
	      currentSumEl.textContent = String(currentSum);
	      targetSumEl.textContent = String(targetSum);
	    }

      function renderRoleGemSelectors() {
        if (roleSelect) {
          roleSelect.value = String(state.uiState?.role || "dealer");
        }
        if (gemTypeSelect) {
          gemTypeSelect.value = String(state.uiState?.gem_type || "stable");
        }
      }

    function renderOptions() {
      const options = Array.isArray(state.uiState.options) ? state.uiState.options : [];
      const normalized = options.slice(0, 4);
      while (normalized.length < 4) {
        normalized.push(null);
      }

      optionsGrid.innerHTML = normalized.map((opt, idx) => {
        const label = escapeHtml(textOfOption(opt));
        const styleClass = optionStyleClass(opt);
        return `
          <button class="option-card ${styleClass} p-3 text-left text-sm font-semibold" ${opt ? "" : "disabled"} data-option-idx="${idx}">
            <div class="text-xs uppercase tracking-wide text-slate-400">옵션 ${idx + 1}</div>
            <div class="mt-1 leading-snug">${label}</div>
          </button>
        `;
      }).join("");

      optionsGrid.querySelectorAll("[data-option-idx]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const idx = asInt(btn.dataset.optionIdx, -1);
          if (idx < 0) return;
          applyOption(idx);
        });
      });
    }

	    function renderSummaryPanels() {
	      rerollsText.textContent = String(asInt(state.uiState.rerolls, 0));
	      countText.textContent = String(asInt(state.uiState.attempts_left, 0));
	      costText.textContent = `${costFromState(asInt(state.uiState.cost_state, 0))}G`;
	    }

    function optionStyleClass(opt) {
      const category = String(opt?.category || "").toLowerCase();
      if (category === "willpower") return "opt-will";
      if (category === "points") return "opt-point";
      if (category === "effect1" || category === "effect1_level") return "opt-eff1";
      if (category === "effect2" || category === "effect2_level") return "opt-eff2";
      if (category === "special") return "opt-special";
      return "opt-special";
    }

    // ===== 옵션 선택 모달 (수동 보정) =====
    const SUBOPT_ID_TO_LABEL_KO = {
      0: "공격력",
      1: "추가피해",
      2: "보스피해",
      3: "아군피해강화",
      4: "낙인력",
      5: "아군공격강화",
    };

    // OCR/서버 추론에서 확실히 잡히는 토큰(화이트리스트)을 raw_option으로 사용한다.
    const SUBOPT_ID_TO_RAW_KO = {
      0: "공격력",
      1: "추가피해",
      2: "보스피해",
      3: "아군피해강화",
      4: "낙인력",
      5: "아군공격력강화",
    };

    const GEM_TYPE_ALLOWED_SUBOPTS = {
      stable: [0, 1, 3, 4],
      solid: [0, 2, 3, 5],
      immutable: [1, 2, 4, 5],
    };

    const ROLE_SUBOPT_WEIGHT = {
      dealer: { 0: 1.0, 1: 2.0, 2: 3.0, 3: 0.0, 4: 0.0, 5: 0.0 },
      support: { 0: 0.0, 1: 0.0, 2: 0.0, 3: 1.0, 4: 2.0, 5: 3.0 },
    };

    let optionPickerSession = null;

    function allowedSuboptsForGemType(gemType) {
      const key = String(gemType || "stable").toLowerCase();
      const ids = GEM_TYPE_ALLOWED_SUBOPTS[key] || GEM_TYPE_ALLOWED_SUBOPTS.stable;
      return Array.isArray(ids) ? ids.slice() : GEM_TYPE_ALLOWED_SUBOPTS.stable.slice();
    }

    function pickDistinctKinds(allowed, preferred1, preferred2) {
      const ids = Array.isArray(allowed) ? allowed.slice() : [];
      if (ids.length < 2) return { e1: 0, e2: 1 };
      let e1 = ids.includes(preferred1) ? preferred1 : ids[0];
      let e2 = ids.includes(preferred2) ? preferred2 : (ids.find((x) => x !== e1) ?? ids[1]);
      if (e1 === e2) {
        e2 = ids.find((x) => x !== e1) ?? e2;
      }
      return { e1, e2 };
    }

    function defaultEffectKindsForPicker(allowed) {
      const used = state.lastResponse?.rl?.state_used;
      const p1 = used ? asInt(used.effect1_kind, -1) : -1;
      const p2 = used ? asInt(used.effect2_kind, -1) : -1;
      if (p1 >= 0 || p2 >= 0) {
        return pickDistinctKinds(allowed, p1, p2);
      }

      const roleKey =
        String(state.uiState?.role || "dealer").toLowerCase() === "support" ? "support" : "dealer";
      const weights = ROLE_SUBOPT_WEIGHT[roleKey] || ROLE_SUBOPT_WEIGHT.dealer;
      const ranked = allowed.slice().sort((a, b) => {
        const wa = Number(weights[a] || 0);
        const wb = Number(weights[b] || 0);
        if (wb !== wa) return wb - wa;
        return a - b;
      });
      const e1 = ranked[0] ?? allowed[0] ?? 0;
      const e2 = ranked.find((x) => x !== e1) ?? ranked[1] ?? allowed[1] ?? 1;
      return { e1, e2 };
    }

    function normalizeOptionArray4(list) {
      const out = Array.isArray(list) ? list.slice(0, 4) : [];
      while (out.length < 4) out.push(null);
      return out;
    }

    function optionKey(opt) {
      if (!opt || typeof opt !== "object") return "";
      const cat = String(opt.category || "").toLowerCase();
      const raw = String(opt.raw_option || opt.option || "").trim();
      const pos = String(opt.position || "").trim();
      const v = asInt(opt.value, 0);
      return `${cat}|${v}|${raw}|${pos}`;
    }

    function ensureUiOptionsLen4() {
      return normalizeOptionArray4(state.uiState?.options);
    }

    function setOptionOverride(idx, opt) {
      if (!state.uiState) return;
      const slot = clampIntRange(asInt(idx, 0), 0, 3);

      const next = ensureUiOptionsLen4();
      next[slot] = opt === undefined ? null : (opt || null);
      state.uiState.options = next;

      const baseOptions = normalizeOptionArray4(state.lastResponse?.ui_state?.options);
      const baseKey = optionKey(baseOptions[slot]);
      const nextKey = optionKey(next[slot]);

      if (!state.optionOverrides || typeof state.optionOverrides !== "object") {
        state.optionOverrides = {};
      }

      // Keep the override map minimal: if user sets the slot back to the server-provided value,
      // drop the override so it won't accidentally affect the next analyze.
      if (baseKey === nextKey) {
        delete state.optionOverrides[String(slot)];
      } else {
        // Allow explicit null to clear the slot.
        state.optionOverrides[String(slot)] = next[slot];
      }

      state.uiOverride.options = Object.keys(state.optionOverrides).length > 0;
      renderAll();
      if (optionPickerSession) renderOptionPickerSlots();
    }

    function restoreOptionsFromLastResponse() {
      if (!state.uiState) return;
      state.uiState.options = normalizeOptionArray4(state.lastResponse?.ui_state?.options);
      state.optionOverrides = {};
      state.uiOverride.options = false;
      renderAll();
      if (optionPickerSession) renderOptionPickerSlots();
    }

    function buildManualOptionItem({ category, value, raw, kindId }) {
      const cat = String(category || "").toLowerCase();
      const v = asInt(value, 0);
      if (cat === "willpower") {
        const sign = v >= 0 ? `+${v}` : `${v}`;
        return {
          text: `의지력 ${sign}`,
          category: "willpower",
          position: "other",
          raw_option: "의지력 효율",
          value: v,
        };
      }
      if (cat === "points") {
        const sign = v >= 0 ? `+${v}` : `${v}`;
        return {
          text: `질서혼돈 ${sign}`,
          category: "points",
          position: "other",
          raw_option: "질서혼돈",
          value: v,
        };
      }
      if (cat === "effect1" || cat === "effect2") {
        const kid = asInt(kindId, -1);
        const rawName = SUBOPT_ID_TO_RAW_KO[kid] || "공격력";
        const label = SUBOPT_ID_TO_LABEL_KO[kid] || rawName;
        const position = cat === "effect1" ? "left" : "right";
        if (v === 0) {
          return {
            text: `${label} 변환`,
            category: cat,
            position,
            raw_option: `${rawName} 변경`,
            value: 0,
          };
        }
        const sign = v >= 0 ? `+${v}` : `${v}`;
        return {
          text: `${label} ${sign}`,
          category: cat,
          position,
          raw_option: rawName,
          value: v,
        };
      }
      if (cat === "special") {
        const key = String(raw || "").trim();
        if (key.includes("비용")) {
          const text = v >= 0 ? "비용 +100%" : "비용 -100%";
          return {
            text,
            category: "special",
            position: "other",
            raw_option: "비용",
            value: v >= 0 ? 100 : -100,
          };
        }
        if (key.includes("새로고침") || key.includes("세로고침")) {
          const gain = Math.max(1, Math.min(2, Math.abs(v || 1)));
          return {
            text: `새로고침 +${gain}`,
            category: "special",
            position: "other",
            raw_option: "새로고침",
            value: gain,
          };
        }
        if (key.includes("상태")) {
          return {
            text: "상태 유지",
            category: "special",
            position: "other",
            raw_option: "상태유지",
            value: 0,
          };
        }
        return {
          text: String(raw || "옵션").trim() || "옵션",
          category: "special",
          position: "other",
          raw_option: String(raw || "").trim(),
          value: v,
        };
      }
      return {
        text: String(raw || "옵션").trim() || "옵션",
        category: cat,
        position: "other",
        raw_option: String(raw || "").trim(),
        value: v,
      };
    }

    function coerceOptionObject(raw) {
      if (!raw || typeof raw !== "object") return null;
      const category = String(raw.category || "").trim().toLowerCase();
      const value = asInt(raw.value, 0);
      const position = String(raw.position || "other").trim() || "other";
      const rawOption = String(raw.raw_option || raw.option || "").trim();
      const text = String(raw.text || raw.formatted || rawOption || "").trim();
      return {
        text: text || "옵션",
        category,
        position,
        raw_option: rawOption || text || "",
        value,
      };
    }

    function renderOptionPickerSlots() {
      if (!optionPickerSlots) return;
      const normalized = ensureUiOptionsLen4();
      const selectedIdx = optionPickerSession ? asInt(optionPickerSession.selectedSlot, 0) : -1;

      optionPickerSlots.innerHTML = normalized
        .map((opt, idx) => {
          const label = escapeHtml(textOfOption(opt));
          const styleClass = optionStyleClass(opt);
          const isSelected = idx === selectedIdx;
          const emptyCls = opt ? "" : "option-slot-empty";
          const selCls = isSelected ? "is-selected" : "";
          return `
            <div class="relative">
              <button
                type="button"
                class="option-card option-slot ${styleClass} ${emptyCls} ${selCls} w-full p-3 text-left text-sm font-semibold"
                data-slot-idx="${idx}"
              >
                <div class="text-xs uppercase tracking-wide text-slate-400">슬롯 ${idx + 1}</div>
                <div class="mt-1 leading-snug">${label}</div>
              </button>
              <button type="button" class="option-slot-clear" data-slot-clear-idx="${idx}" aria-label="비우기">×</button>
            </div>
          `;
        })
        .join("");
    }

    function optionFromChoiceButton(btn) {
      const category = String(btn?.dataset?.choiceCat || "");
      const value = asInt(btn?.dataset?.choiceVal, 0);
      const raw = String(btn?.dataset?.choiceRaw || "");
      const kindId = btn?.dataset?.choiceKind != null ? asInt(btn.dataset.choiceKind, -1) : null;
      return buildManualOptionItem({ category, value, raw, kindId });
    }

    function togglePickerKindMenu(which) {
      if (!optionPickerSession) return;
      optionPickerSession.kindMenuOpen = optionPickerSession.kindMenuOpen === which ? null : which;
      renderOptionPickerPalette();
    }

    function setPickerKind(which, kindId) {
      if (!optionPickerSession) return;
      const allowed = allowedSuboptsForGemType(state.uiState?.gem_type || "stable");
      const kid = asInt(kindId, -1);
      if (!allowed.includes(kid)) return;

      const cur1 = asInt(optionPickerSession.effect1Kind, -1);
      const cur2 = asInt(optionPickerSession.effect2Kind, -1);
      if (which === "effect1") {
        if (kid === cur2) {
          optionPickerSession.effect1Kind = cur2;
          optionPickerSession.effect2Kind = cur1;
        } else {
          optionPickerSession.effect1Kind = kid;
        }
      } else if (which === "effect2") {
        if (kid === cur1) {
          optionPickerSession.effect2Kind = cur1;
          optionPickerSession.effect1Kind = cur2;
        } else {
          optionPickerSession.effect2Kind = kid;
        }
      }

      // Keep both kinds valid/distinct.
      const picked = pickDistinctKinds(allowed, optionPickerSession.effect1Kind, optionPickerSession.effect2Kind);
      optionPickerSession.effect1Kind = picked.e1;
      optionPickerSession.effect2Kind = picked.e2;
      optionPickerSession.kindMenuOpen = null;
      renderOptionPickerPalette();
    }

    function renderOptionPickerPalette() {
      if (!optionPickerSession || !optionPickerPaletteWrap) return;
      const allowed = allowedSuboptsForGemType(state.uiState?.gem_type || "stable");

      const picked = pickDistinctKinds(
        allowed,
        optionPickerSession.effect1Kind,
        optionPickerSession.effect2Kind,
      );
      optionPickerSession.effect1Kind = picked.e1;
      optionPickerSession.effect2Kind = picked.e2;

      const e1Label = SUBOPT_ID_TO_LABEL_KO[picked.e1] || "부옵션1";
      const e2Label = SUBOPT_ID_TO_LABEL_KO[picked.e2] || "부옵션2";
      const canChangeEffectKind = allowed.filter((id) => id !== picked.e1 && id !== picked.e2).length > 0;
      const kindMenuOpen = String(optionPickerSession.kindMenuOpen || "");

      const wpCur = asInt(state.current.willpower, 1);
      const ptCur = asInt(state.current.points, 1);
      const e1Cur = asInt(state.current.effect1_level, 1);
      const e2Cur = asInt(state.current.effect2_level, 1);

      const attemptsLeft = asInt(state.uiState?.attempts_left, 0);
      const costState = asInt(state.uiState?.cost_state, 0);

      const deltaVals = [1, 2, 3, 4, -1];

      const mkDeltaBtn = ({ cat, val, name, styleClass, disabled, raw, kindId }) => {
        const v = asInt(val, 0);
        const sign = v >= 0 ? `+${v}` : `${v}`;
        const valueCls = v < 0 ? "text-rose-200" : "text-slate-50";
        return `
          <button
            type="button"
            draggable="true"
            class="option-card option-choice ${styleClass} p-2 text-center text-sm font-extrabold leading-tight"
            ${disabled ? "disabled" : ""}
            data-choice-cat="${escapeHtml(cat)}"
            data-choice-val="${escapeHtml(String(v))}"
            ${raw ? `data-choice-raw="${escapeHtml(raw)}"` : ""}
            ${kindId != null ? `data-choice-kind="${escapeHtml(String(kindId))}"` : ""}
          >
            <div>${escapeHtml(name)}</div>
            <div class="mt-0.5 ${valueCls}">${escapeHtml(sign)}</div>
          </button>
        `;
      };

      const mkTextBtn = ({ cat, val, name, valueText, styleClass, disabled, raw, kindId, valueCls }) => {
        const v = asInt(val, 0);
        return `
          <button
            type="button"
            draggable="true"
            class="option-card option-choice ${styleClass} p-2 text-center text-sm font-extrabold leading-tight"
            ${disabled ? "disabled" : ""}
            data-choice-cat="${escapeHtml(cat)}"
            data-choice-val="${escapeHtml(String(v))}"
            ${raw ? `data-choice-raw="${escapeHtml(raw)}"` : ""}
            ${kindId != null ? `data-choice-kind="${escapeHtml(String(kindId))}"` : ""}
          >
            <div>${escapeHtml(name)}</div>
            <div class="mt-0.5 ${valueCls || "text-slate-50"}">${escapeHtml(valueText)}</div>
          </button>
        `;
      };

      const colWill = `
        <div class="rounded-lg border border-slate-700/80 bg-slate-950/40 p-2">
          <div class="flex h-4 items-center text-[11px] font-semibold uppercase tracking-wide text-slate-300 leading-none">의지력</div>
          <div class="mt-2 grid gap-2">
            ${deltaVals.map((v) => mkDeltaBtn({
              cat: "willpower",
              val: v,
              name: "의지력",
              styleClass: "opt-will",
              disabled: wpCur + v < 1 || wpCur + v > 5,
            })).join("")}
          </div>
        </div>
      `;

      const colPoints = `
        <div class="rounded-lg border border-slate-700/80 bg-slate-950/40 p-2">
          <div class="flex h-4 items-center text-[11px] font-semibold uppercase tracking-wide text-slate-300 leading-none">질서혼돈</div>
          <div class="mt-2 grid gap-2">
            ${deltaVals.map((v) => mkDeltaBtn({
              cat: "points",
              val: v,
              name: "질서혼돈",
              styleClass: "opt-point",
              disabled: ptCur + v < 1 || ptCur + v > 5,
            })).join("")}
          </div>
        </div>
      `;

      const colEff1 = `
        <div class="rounded-lg border border-slate-700/80 bg-slate-950/40 p-2">
          <div class="relative">
            <div class="flex h-4 items-center justify-between text-[11px] font-semibold uppercase tracking-wide text-slate-300 leading-none">
              <span class="truncate">${escapeHtml(e1Label)}</span>
              <button
                type="button"
                class="glow-btn rounded-md border border-transparent bg-transparent px-1 text-[12px] leading-none text-slate-300 hover:border-slate-500/50 hover:bg-slate-900/30 hover:text-slate-100"
                title="부옵션 종류 선택"
                aria-label="부옵션 종류 선택"
                data-kind-menu-toggle="effect1"
              >▾</button>
            </div>
            <div
              class="${kindMenuOpen === "effect1" ? "" : "hidden"} absolute left-0 top-full z-30 mt-1 w-full rounded-md border border-slate-700/80 bg-slate-950/95 p-1 shadow-lg"
              data-kind-menu-panel="effect1"
            >
              ${allowed
                .map((kid) => {
                  const label = SUBOPT_ID_TO_LABEL_KO[kid] || `부옵션${kid}`;
                  const isCur = kid === picked.e1;
                  const mark = isCur ? "✓" : "";
                  const cls = isCur ? "bg-cyan-400/10 text-cyan-100" : "text-slate-200 hover:bg-slate-900/40";
                  return `
                    <button
                      type="button"
                      class="${cls} flex w-full items-center justify-between gap-3 rounded-md px-2 py-1.5 text-xs"
                      data-kind-choice="effect1"
                      data-kind-id="${escapeHtml(String(kid))}"
                    >
                      <span>${escapeHtml(label)}</span>
                      <span class="text-[11px] text-slate-400">${escapeHtml(mark)}</span>
                    </button>
                  `;
                })
                .join("")}
            </div>
          </div>
          <div class="mt-2 grid gap-2">
            ${deltaVals.map((v) => mkDeltaBtn({
              cat: "effect1",
              val: v,
              name: e1Label,
              styleClass: "opt-eff1",
              disabled: e1Cur + v < 1 || e1Cur + v > 5,
              kindId: picked.e1,
            })).join("")}
          </div>
        </div>
      `;

      const colEff2 = `
        <div class="rounded-lg border border-slate-700/80 bg-slate-950/40 p-2">
          <div class="relative">
            <div class="flex h-4 items-center justify-between text-[11px] font-semibold uppercase tracking-wide text-slate-300 leading-none">
              <span class="truncate">${escapeHtml(e2Label)}</span>
              <button
                type="button"
                class="glow-btn rounded-md border border-transparent bg-transparent px-1 text-[12px] leading-none text-slate-300 hover:border-slate-500/50 hover:bg-slate-900/30 hover:text-slate-100"
                title="부옵션 종류 선택"
                aria-label="부옵션 종류 선택"
                data-kind-menu-toggle="effect2"
              >▾</button>
            </div>
            <div
              class="${kindMenuOpen === "effect2" ? "" : "hidden"} absolute left-0 top-full z-30 mt-1 w-full rounded-md border border-slate-700/80 bg-slate-950/95 p-1 shadow-lg"
              data-kind-menu-panel="effect2"
            >
              ${allowed
                .map((kid) => {
                  const label = SUBOPT_ID_TO_LABEL_KO[kid] || `부옵션${kid}`;
                  const isCur = kid === picked.e2;
                  const mark = isCur ? "✓" : "";
                  const cls = isCur ? "bg-cyan-400/10 text-cyan-100" : "text-slate-200 hover:bg-slate-900/40";
                  return `
                    <button
                      type="button"
                      class="${cls} flex w-full items-center justify-between gap-3 rounded-md px-2 py-1.5 text-xs"
                      data-kind-choice="effect2"
                      data-kind-id="${escapeHtml(String(kid))}"
                    >
                      <span>${escapeHtml(label)}</span>
                      <span class="text-[11px] text-slate-400">${escapeHtml(mark)}</span>
                    </button>
                  `;
                })
                .join("")}
            </div>
          </div>
          <div class="mt-2 grid gap-2">
            ${deltaVals.map((v) => mkDeltaBtn({
              cat: "effect2",
              val: v,
              name: e2Label,
              styleClass: "opt-eff2",
              disabled: e2Cur + v < 1 || e2Cur + v > 5,
              kindId: picked.e2,
            })).join("")}
          </div>
        </div>
      `;

      const disableReroll = attemptsLeft <= 1;
      const disableCost = attemptsLeft <= 1;
      const colSpecial = `
        <div class="rounded-lg border border-slate-700/80 bg-slate-950/40 p-2">
          <div class="flex h-4 items-center text-[11px] font-semibold uppercase tracking-wide text-slate-300 leading-none">특수</div>
          <div class="mt-2 grid gap-2">
            ${mkTextBtn({
              cat: "special",
              val: 0,
              name: "상태유지",
              valueText: "유지",
              styleClass: "opt-special",
              disabled: false,
              raw: "상태유지",
              valueCls: "text-slate-50",
            })}
            ${mkTextBtn({
              cat: "special",
              val: 1,
              name: "새로고침",
              valueText: "+1",
              styleClass: "opt-special",
              disabled: disableReroll,
              raw: "새로고침",
              valueCls: "text-slate-50",
            })}
            ${mkTextBtn({
              cat: "special",
              val: 2,
              name: "새로고침",
              valueText: "+2",
              styleClass: "opt-special",
              disabled: disableReroll,
              raw: "새로고침",
              valueCls: "text-slate-50",
            })}
            ${mkTextBtn({
              cat: "special",
              val: 100,
              name: "비용",
              valueText: "+100%",
              styleClass: "opt-special",
              disabled: disableCost || costState >= 1,
              raw: "비용",
              valueCls: "text-slate-50",
            })}
            ${mkTextBtn({
              cat: "special",
              val: -100,
              name: "비용",
              valueText: "-100%",
              styleClass: "opt-special",
              disabled: disableCost || costState <= -1,
              raw: "비용",
              valueCls: "text-rose-200",
            })}
          </div>
        </div>
      `;

      const transformRow = `
        <div class="mt-3 grid grid-cols-5 gap-3">
          <div></div>
          <div></div>
          ${mkTextBtn({
            cat: "effect1",
            val: 0,
            name: e1Label,
            valueText: "변환",
            styleClass: "opt-eff1",
            disabled: !canChangeEffectKind,
            kindId: picked.e1,
            valueCls: "text-slate-50",
          })}
          ${mkTextBtn({
            cat: "effect2",
            val: 0,
            name: e2Label,
            valueText: "변환",
            styleClass: "opt-eff2",
            disabled: !canChangeEffectKind,
            kindId: picked.e2,
            valueCls: "text-slate-50",
          })}
          <div></div>
        </div>
      `;

      optionPickerPaletteWrap.innerHTML = `
        <div class="grid grid-cols-5 gap-3">
          ${[colWill, colPoints, colEff1, colEff2, colSpecial].join("")}
        </div>
        ${transformRow}
      `;
    }

    function renderOptionPickerModal() {
      if (!optionPickerSession) return;
      renderOptionPickerSlots();
      renderOptionPickerPalette();
    }

    function openOptionPickerModal() {
      if (!optionPickerModal || !optionPickerSlots || !optionPickerPaletteWrap) return;
      const allowed = allowedSuboptsForGemType(state.uiState?.gem_type || "stable");
      const picked = defaultEffectKindsForPicker(allowed);
      optionPickerSession = {
        selectedSlot: 0,
        effect1Kind: picked.e1,
        effect2Kind: picked.e2,
      };
      renderOptionPickerModal();
      optionPickerModal.classList.remove("hidden");
      optionPickerModal.classList.add("flex");
    }

    function closeOptionPickerModal() {
      if (!optionPickerModal) return;
      optionPickerSession = null;
      optionPickerModal.classList.add("hidden");
      optionPickerModal.classList.remove("flex");
    }

    function bindOptionPickerControls() {
      if (!optionPickerBtn || !optionPickerModal || !optionPickerSlots || !optionPickerPaletteWrap) return;
      if (optionPickerModal.dataset.bound === "1") return;
      optionPickerModal.dataset.bound = "1";

      optionPickerBtn.addEventListener("click", openOptionPickerModal);

      if (optionPickerCloseBtn) {
        optionPickerCloseBtn.addEventListener("click", closeOptionPickerModal);
      }
      if (optionPickerRestoreBtn) {
        optionPickerRestoreBtn.addEventListener("click", restoreOptionsFromLastResponse);
      }

      optionPickerModal.addEventListener("click", (ev) => {
        if (ev.target === optionPickerModal) closeOptionPickerModal();
      });

      window.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape" && optionPickerSession) {
          closeOptionPickerModal();
        }
      });

      optionPickerSlots.addEventListener("click", (ev) => {
        const clearBtn = ev.target && ev.target.closest ? ev.target.closest("[data-slot-clear-idx]") : null;
        if (clearBtn) {
          const idx = asInt(clearBtn.dataset.slotClearIdx, -1);
          if (idx >= 0) setOptionOverride(idx, null);
          return;
        }
        const slotBtn = ev.target && ev.target.closest ? ev.target.closest("[data-slot-idx]") : null;
        if (!slotBtn || !optionPickerSession) return;
        const idx = asInt(slotBtn.dataset.slotIdx, -1);
        if (idx < 0) return;
        optionPickerSession.selectedSlot = idx;
        renderOptionPickerSlots();
      });

      optionPickerSlots.addEventListener("dragover", (ev) => {
        const slotBtn = ev.target && ev.target.closest ? ev.target.closest("[data-slot-idx]") : null;
        if (!slotBtn || slotBtn.disabled) return;
        ev.preventDefault();
        slotBtn.classList.add("is-drop-hover");
      });

      optionPickerSlots.addEventListener("dragleave", (ev) => {
        const slotBtn = ev.target && ev.target.closest ? ev.target.closest("[data-slot-idx]") : null;
        if (!slotBtn) return;
        slotBtn.classList.remove("is-drop-hover");
      });

      optionPickerSlots.addEventListener("drop", (ev) => {
        const slotBtn = ev.target && ev.target.closest ? ev.target.closest("[data-slot-idx]") : null;
        if (!slotBtn) return;
        ev.preventDefault();
        slotBtn.classList.remove("is-drop-hover");
        const idx = asInt(slotBtn.dataset.slotIdx, -1);
        if (idx < 0) return;
        const raw = (ev.dataTransfer && ev.dataTransfer.getData && ev.dataTransfer.getData("text/plain")) || "";
        let parsed = null;
        try {
          parsed = raw ? JSON.parse(raw) : null;
        } catch (_err) {
          parsed = null;
        }
        const opt = coerceOptionObject(parsed);
        if (!opt) return;
        if (optionPickerSession) optionPickerSession.selectedSlot = idx;
        setOptionOverride(idx, opt);
      });

      optionPickerPaletteWrap.addEventListener("click", (ev) => {
        const kindMenuBtn = ev.target && ev.target.closest ? ev.target.closest("[data-kind-menu-toggle]") : null;
        if (kindMenuBtn && optionPickerSession) {
          const which = String(kindMenuBtn.dataset.kindMenuToggle || "");
          if (which === "effect1" || which === "effect2") togglePickerKindMenu(which);
          return;
        }

        const kindChoiceBtn = ev.target && ev.target.closest ? ev.target.closest("[data-kind-choice]") : null;
        if (kindChoiceBtn && optionPickerSession) {
          const which = String(kindChoiceBtn.dataset.kindChoice || "");
          const kid = asInt(kindChoiceBtn.dataset.kindId, -1);
          if (which === "effect1" || which === "effect2") setPickerKind(which, kid);
          return;
        }

        const btn = ev.target && ev.target.closest ? ev.target.closest("[data-choice-cat]") : null;
        if (!btn || btn.disabled || !optionPickerSession) return;
        const opt = optionFromChoiceButton(btn);
        const slot = clampIntRange(asInt(optionPickerSession.selectedSlot, 0), 0, 3);
        if (optionPickerSession.kindMenuOpen) {
          optionPickerSession.kindMenuOpen = null;
          renderOptionPickerPalette();
        }
        setOptionOverride(slot, opt);
      });

      optionPickerPaletteWrap.addEventListener("dragstart", (ev) => {
        const btn = ev.target && ev.target.closest ? ev.target.closest("[data-choice-cat]") : null;
        if (!btn || btn.disabled) return;
        const opt = optionFromChoiceButton(btn);
        try {
          ev.dataTransfer.setData("text/plain", JSON.stringify(opt));
          ev.dataTransfer.effectAllowed = "copy";
        } catch (_err) {
          // ignore
        }
      });
    }

    function renderAction(rl) {
      if (!rl || !rl.action_name) {
        actionText.textContent = "-";
        actionText.className = "mt-1 text-lg font-extrabold text-slate-200";
        return;
      }

      const action = String(rl.action_name);
      const actionNameKo = actionKo(action);
      actionText.textContent = actionNameKo;

      if (action === "process") {
        actionText.className = "mt-1 text-lg font-extrabold text-emerald-300";
      } else if (action === "reroll") {
        actionText.className = "mt-1 text-lg font-extrabold text-cyan-300";
      } else {
        actionText.className = "mt-1 text-lg font-extrabold text-amber-300";
      }
    }

	    function renderSuccessProb() {
	      if (state.successProb == null) {
	        successProbText.textContent = "-";
	        return;
	      }

	      const p = Number(state.successProb);
	      if (!Number.isFinite(p)) {
	        successProbText.textContent = "-";
	        return;
	      }

	      const pct = Math.max(0, Math.min(1, p)) * 100;
	      if (pct > 0 && pct < 0.1) {
	        successProbText.textContent = "<0.1%";
	        return;
	      }
	      if (pct < 1) {
	        successProbText.textContent = `${pct.toFixed(2)}%`;
	        return;
	      }
	      successProbText.textContent = `${pct.toFixed(1)}%`;
	    }

		    function renderAll() {
		      renderStatInputs();
		      renderSums();
          renderRoleGemSelectors();
		      renderSummaryPanels();
		      renderOptions();
		      renderAction(state.lastResponse?.rl || null);
	      renderSuccessProb();
	      renderError();
          if (optionPickerSession) renderOptionPickerModal();
	    }

		    function renderError() {
		      if (!analyzeError) return;
		      const msg = state.lastError ? String(state.lastError) : "";
		      if (!msg) {
		        analyzeError.textContent = "";
	        analyzeError.classList.add("hidden");
	        return;
	      }
		      analyzeError.textContent = msg;
		      analyzeError.classList.remove("hidden");
		    }

	    function setBugReportStatus(message, tone = "info") {
	      if (!bugReportStatus) return;
	      const text = String(message || "").trim();
	      if (!text) {
	        bugReportStatus.textContent = "";
	        bugReportStatus.className = "hidden text-xs";
	        return;
	      }
	      let cls = "text-slate-300";
	      if (tone === "ok") cls = "text-emerald-300";
	      if (tone === "error") cls = "text-rose-300";
	      bugReportStatus.textContent = text;
	      bugReportStatus.className = `text-xs ${cls}`;
	    }

	    async function submitBugReport() {
	      if (!bugReportInput || !bugReportSendBtn) return;
	      const message = String(bugReportInput.value || "").trim();
	      if (!message) {
	        setBugReportStatus("내용을 입력해주세요.", "error");
	        return;
	      }

	      bugReportSendBtn.disabled = true;
	      setBugReportStatus("전송 중...", "info");
		      try {
		        const fd = new FormData();
		        fd.append("message", message);
            if (state.clientId) {
              fd.append("client_id", String(state.clientId));
            }
		        const recordId = state.lastResponse?.record?.id;
		        if (recordId) {
		          fd.append("record_id", String(recordId));
		        }
	        const res = await fetch("/api/report", {
	          method: "POST",
	          body: fd,
	        });
	        const body = await res.json().catch(() => ({}));
	        if (!res.ok || !body.ok) {
	          const detail = body?.detail || body?.error || res.statusText || "unknown";
	          throw new Error(`제보 저장 실패: ${detail}`);
	        }
	        bugReportInput.value = "";
	        setBugReportStatus("제보가 저장되었습니다. 감사합니다!", "ok");
	      } catch (err) {
	        const msg = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
	        setBugReportStatus(msg || "제보 전송 실패", "error");
	      } finally {
	        bugReportSendBtn.disabled = false;
	      }
	    }

	    function setSharingUI(isSharing) {
	      shareStartBtn.disabled = isSharing;
      shareStopBtn.disabled = !isSharing;
      analyzeBtn.disabled = !isSharing;
      if (roiAdjustBtn) roiAdjustBtn.disabled = !isSharing;
    }

    async function checkBackendHealthy() {
      try {
        const res = await fetch("/api/health", { cache: "no-store" });
        const body = await res.json().catch(() => ({}));
        const ok = Boolean(res.ok && body && body.ok && (body.backend_ok === undefined || body.backend_ok));
        if (ok) return { ok: true };
        const detail = body?.detail || body?.error || res.statusText || "backend unavailable";
        return { ok: false, detail: String(detail) };
      } catch (err) {
        const msg = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
        return { ok: false, detail: msg || "backend unreachable" };
      }
    }

    async function startShare() {
      if (!navigator.mediaDevices?.getDisplayMedia) {
        alert("이 브라우저는 화면 공유 API를 지원하지 않습니다.");
        return;
      }

      const health = await refreshServerStatus();
      if (!health.ok) {
        alert("서버 점검중입니다. 기다려주셔서 감사합니다.");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: { frameRate: 15 },
          audio: false,
        });
        state.stream = stream;
        screenVideo.srcObject = stream;
        screenVideo.play().catch(() => {});

        const track = stream.getVideoTracks()[0];
        if (track) {
          track.addEventListener("ended", () => {
            stopShare();
          });
        }

        setSharingUI(true);
      } catch (err) {
        setSharingUI(false);
      }
    }

    function stopShare() {
      if (state.stream) {
        state.stream.getTracks().forEach((t) => t.stop());
      }
      state.stream = null;
      screenVideo.srcObject = null;
      setSharingUI(false);
    }

    const ROI_SCHEMA_VERSION = "screen_v2_multicrop";
    const CAPTURE_PIPELINE = "multi_crop_png";
    const FALLBACK_ROI_SCHEMA_VERSION = "screen_v1";
    const FALLBACK_CAPTURE_PIPELINE = "fullframe_resized_jpeg";
    const ROI_BASE_WIDTH = 2560;
    const ROI_BASE_HEIGHT = 1440;
    const ROI_BOXES = [
      { label: "option1", x: 1043.72, y: 793.61, w: 150.71, h: 112.23 },
      { label: "option2", x: 1197.63, y: 795.22, w: 147.50, h: 105.81 },
      { label: "option3", x: 1360.36, y: 796.02, w: 158.72, h: 113.83 },
      { label: "option4", x: 1512.67, y: 795.22, w: 152.31, h: 109.02 },
      { label: "possible", x: 1669.79, y: 794.41, w: 126.66, h: 59.32 },
      // NOTE: cost is slightly enlarged to avoid clipping digits under different UI scales
      // (e.g. "1,800" losing the leading '1'). Count is shifted/tightened to focus the "(n/7)" text.
      { label: "cost", x: 1579.21, y: 887.40, w: 150.00, h: 70.00 },
      { label: "count", x: 1496.60, y: 1022.08, w: 80.00, h: 80.00 },
    ];
    const ROI_OVERRIDE_STORAGE_KEY = "gemmini_roi_overrides_screen_v2";
    const ROI_OVERRIDE_STORAGE_REV = 2;
    const ROI_COUNT_OVERRIDE_MIGRATE_DX = 20.0; // old(default=1476.60) -> new(default=1496.60)
    const ROI_ADJUST_LABELS = ["option1", "option2", "option3", "option4", "possible", "cost", "count"];

    function loadRoiOverridesFromStorage() {
      try {
        const raw = String(window.localStorage.getItem(ROI_OVERRIDE_STORAGE_KEY) || "").trim();
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        const rev = asInt(parsed.__rev, 1);
        const out = {};
        for (const label of ROI_ADJUST_LABELS) {
          const v = parsed[label];
          if (!v || typeof v !== "object") continue;
          let x = Number(v.x);
          const y = Number(v.y);
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
          if (label === "count" && rev < ROI_OVERRIDE_STORAGE_REV) {
            x += ROI_COUNT_OVERRIDE_MIGRATE_DX;
          }
          out[label] = {
            x: Math.max(0, Math.min(ROI_BASE_WIDTH, x)),
            y: Math.max(0, Math.min(ROI_BASE_HEIGHT, y)),
          };
        }
        return Object.keys(out).length ? out : null;
      } catch (_err) {
        return null;
      }
    }

    function saveRoiOverridesToStorage(overrides) {
      try {
        if (!overrides || typeof overrides !== "object") {
          window.localStorage.removeItem(ROI_OVERRIDE_STORAGE_KEY);
          return;
        }
        const payload = { ...overrides, __rev: ROI_OVERRIDE_STORAGE_REV };
        window.localStorage.setItem(ROI_OVERRIDE_STORAGE_KEY, JSON.stringify(payload));
      } catch (_err) {
        // ignore storage failures
      }
    }

    function applyRoiOverrides(box, overrides) {
      const ov = overrides && typeof overrides === "object" ? overrides[box.label] : null;
      if (!ov) return box;
      const x = Number(ov.x);
      const y = Number(ov.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return box;
      return { ...box, x, y };
    }

    // Load persisted ROI adjustments after the schema constants exist.
    if (state && state.roiOverrides == null) {
      state.roiOverrides = loadRoiOverridesFromStorage();
    }
    const CAPTURE_MAX_LONG_EDGE = 1920;
    const CAPTURE_TARGET_BYTES = 1_600_000; // ~1.6MB
    const CAPTURE_INITIAL_JPEG_QUALITY = 0.86;
    const CAPTURE_MIN_JPEG_QUALITY = 0.62;

    function fitSize(width, height, maxLongEdge) {
      const w = Math.max(1, asInt(width, 1));
      const h = Math.max(1, asInt(height, 1));
      const longEdge = Math.max(w, h);
      if (longEdge <= maxLongEdge) return { width: w, height: h };
      const scale = maxLongEdge / longEdge;
      return {
        width: Math.max(1, Math.round(w * scale)),
        height: Math.max(1, Math.round(h * scale)),
      };
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("Failed to capture frame blob."));
            return;
          }
          resolve(blob);
        }, type, quality);
      });
    }

    function computeRoiContentMapping(srcW, srcH) {
      const baseAspect = ROI_BASE_WIDTH / ROI_BASE_HEIGHT;
      const srcAspect = srcW / srcH;
      const eps = 0.02; // tolerate small rounding differences
      let contentX = 0;
      let contentY = 0;
      let contentW = srcW;
      let contentH = srcH;
      let letterboxMode = "direct";
      if (Number.isFinite(srcAspect) && srcAspect > 0 && Math.abs(srcAspect - baseAspect) > eps) {
        if (srcAspect > baseAspect) {
          // wider than base -> crop horizontally (use centered 16:9 region)
          contentW = Math.max(1, Math.round(srcH * baseAspect));
          contentH = srcH;
          contentX = Math.max(0, Math.round((srcW - contentW) / 2));
          contentY = 0;
          letterboxMode = "crop_x";
        } else {
          // taller than base -> crop vertically
          contentW = srcW;
          contentH = Math.max(1, Math.round(srcW / baseAspect));
          contentX = 0;
          contentY = Math.max(0, Math.round((srcH - contentH) / 2));
          letterboxMode = "crop_y";
        }
      }

      const scaleX = contentW / ROI_BASE_WIDTH;
      const scaleY = contentH / ROI_BASE_HEIGHT;
      return {
        contentX,
        contentY,
        contentW,
        contentH,
        scaleX,
        scaleY,
        letterbox: {
          mode: letterboxMode,
          content_x: contentX,
          content_y: contentY,
          content_w: contentW,
          content_h: contentH,
          src_aspect: Math.round((srcAspect || 0) * 1000) / 1000,
          base_aspect: Math.round(baseAspect * 1000) / 1000,
        },
      };
    }

	    function scaledRoiRect(box, srcW, srcH) {
        // If the captured video is not the same aspect ratio as the ROI schema
        // (e.g. 21:9 ultrawide), the game UI is typically centered with extra
        // horizontal content. Map ROI coordinates onto the centered base-aspect
        // content rect instead of stretching across the full frame.
        const mapping = computeRoiContentMapping(srcW, srcH);
	      const scaleX = mapping.scaleX;
	      const scaleY = mapping.scaleY;
	      const cx = mapping.contentX + box.x * scaleX;
	      const cy = mapping.contentY + box.y * scaleY;
	      const bw = Math.max(1, Math.round(box.w * scaleX));
	      const bh = Math.max(1, Math.round(box.h * scaleY));

      const x1 = Math.max(0, Math.floor(cx - bw / 2));
      const y1 = Math.max(0, Math.floor(cy - bh / 2));
      const x2 = Math.min(srcW, Math.ceil(cx + bw / 2));
      const y2 = Math.min(srcH, Math.ceil(cy + bh / 2));

	      return {
	        x: x1,
	        y: y1,
	        w: Math.max(1, x2 - x1),
	        h: Math.max(1, y2 - y1),
          letterbox: mapping.letterbox,
	      };
	    }

	    async function captureMultiCropPayload() {
      if (!screenVideo.videoWidth || !screenVideo.videoHeight) {
        throw new Error("No screen frame available.");
      }
	      const srcW = screenVideo.videoWidth;
	      const srcH = screenVideo.videoHeight;
	      const rois = [];
        let letterbox = null;
	      for (const box of ROI_BOXES) {
	        const rect = scaledRoiRect(applyRoiOverrides(box, state.roiOverrides), srcW, srcH);
          if (!letterbox && rect.letterbox) {
            letterbox = rect.letterbox;
          }
	        if (rect.w < 8 || rect.h < 8) {
	          throw new Error(`ROI too small: ${box.label}`);
	        }
        const canvas = document.createElement("canvas");
        canvas.width = rect.w;
        canvas.height = rect.h;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Canvas context unavailable.");
        }
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(
          screenVideo,
          rect.x,
          rect.y,
          rect.w,
          rect.h,
          0,
          0,
          rect.w,
          rect.h
        );
	        const blob = await canvasToBlob(canvas, "image/png");
	        rois.push({ label: box.label, rect, blob });
	      }
	      return { source_w: srcW, source_h: srcH, letterbox, rois };
	    }

    function captureVideoFrameBlob() {
      return new Promise(async (resolve, reject) => {
        if (!screenVideo.videoWidth || !screenVideo.videoHeight) {
          reject(new Error("No screen frame available."));
          return;
        }

        const srcW = screenVideo.videoWidth;
        const srcH = screenVideo.videoHeight;
        const resized = fitSize(srcW, srcH, CAPTURE_MAX_LONG_EDGE);

        const canvas = document.createElement("canvas");
        canvas.width = resized.width;
        canvas.height = resized.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Canvas context unavailable."));
          return;
        }
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);

        try {
          let quality = CAPTURE_INITIAL_JPEG_QUALITY;
          let blob = await canvasToBlob(canvas, "image/jpeg", quality);
          while (blob.size > CAPTURE_TARGET_BYTES && quality > CAPTURE_MIN_JPEG_QUALITY) {
            quality = Math.max(CAPTURE_MIN_JPEG_QUALITY, quality - 0.08);
            blob = await canvasToBlob(canvas, "image/jpeg", quality);
            if (quality <= CAPTURE_MIN_JPEG_QUALITY) break;
          }
          resolve({
            blob,
            source_w: srcW,
            source_h: srcH,
            upload_w: canvas.width,
            upload_h: canvas.height,
            jpeg_quality: quality,
          });
        } catch (err) {
          reject(err);
        }
      });
    }

    let roiAdjustSession = null;
    let roiAdjustDrag = null;

    function cloneJson(v) {
      try {
        return v == null ? v : JSON.parse(JSON.stringify(v));
      } catch (_err) {
        return null;
      }
    }

    function buildRoiDraftFromCurrent(overridesRaw) {
      const overrides = overridesRaw && typeof overridesRaw === "object" ? overridesRaw : {};
      const draft = {};
      for (const label of ROI_ADJUST_LABELS) {
        const def = ROI_BOXES.find((b) => b.label === label);
        if (!def) continue;
        const ov = overrides[label];
        const x = Number(ov && typeof ov === "object" ? ov.x : def.x);
        const y = Number(ov && typeof ov === "object" ? ov.y : def.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        draft[label] = {
          x: Math.max(0, Math.min(ROI_BASE_WIDTH, x)),
          y: Math.max(0, Math.min(ROI_BASE_HEIGHT, y)),
        };
      }
      return draft;
    }

    function computeContainRect(containerW, containerH, contentW, contentH) {
      const cw = Math.max(1, Number(containerW) || 1);
      const ch = Math.max(1, Number(containerH) || 1);
      const iw = Math.max(1, Number(contentW) || 1);
      const ih = Math.max(1, Number(contentH) || 1);
      const scale = Math.min(cw / iw, ch / ih);
      const w = iw * scale;
      const h = ih * scale;
      const x = (cw - w) / 2;
      const y = (ch - h) / 2;
      return { x, y, w, h, scale };
    }

    function setBoxStyle(el, rect) {
      if (!el || !rect) return;
      el.style.left = `${Math.round(rect.x)}px`;
      el.style.top = `${Math.round(rect.y)}px`;
      el.style.width = `${Math.max(1, Math.round(rect.w))}px`;
      el.style.height = `${Math.max(1, Math.round(rect.h))}px`;
    }

    function roiOverlayDeltaToBaseDelta(dxOverlay, dyOverlay, session) {
      if (!roiAdjustPreviewWrap || !session) return { dxBase: 0, dyBase: 0 };
      const wrapRect = roiAdjustPreviewWrap.getBoundingClientRect();
      const contain = computeContainRect(wrapRect.width, wrapRect.height, session.preview_w, session.preview_h);
      const mapping = computeRoiContentMapping(session.src_w, session.src_h);
      const cScale = Number(contain.scale) || 1;
      const pScale = Number(session.preview_scale) || 1;
      const denomX = cScale * pScale * (Number(mapping.scaleX) || 1);
      const denomY = cScale * pScale * (Number(mapping.scaleY) || 1);
      if (!Number.isFinite(denomX) || !Number.isFinite(denomY) || denomX === 0 || denomY === 0) {
        return { dxBase: 0, dyBase: 0 };
      }
      return { dxBase: dxOverlay / denomX, dyBase: dyOverlay / denomY };
    }

    function renderRoiAdjustOverlay() {
      if (!roiAdjustSession || !roiAdjustPreviewWrap) return;
      const session = roiAdjustSession;
      const wrapRect = roiAdjustPreviewWrap.getBoundingClientRect();
      const contain = computeContainRect(wrapRect.width, wrapRect.height, session.preview_w, session.preview_h);

      const srcW = session.src_w;
      const srcH = session.src_h;
      const pScale = session.preview_scale;

      function srcRectToOverlayRect(srcRect) {
        const px = srcRect.x * pScale;
        const py = srcRect.y * pScale;
        const pw = srcRect.w * pScale;
        const ph = srcRect.h * pScale;
        return {
          x: contain.x + px * contain.scale,
          y: contain.y + py * contain.scale,
          w: pw * contain.scale,
          h: ph * contain.scale,
        };
      }

      const optionRects = [];
      for (const label of ["option1", "option2", "option3", "option4"]) {
        const def = ROI_BOXES.find((b) => b.label === label);
        const xy = session.draft[label];
        if (!def || !xy) continue;
        optionRects.push(
          scaledRoiRect({ ...def, x: xy.x, y: xy.y }, srcW, srcH)
        );
      }

      if (optionRects.length === 4 && roiDragOptions) {
        const xmin = Math.min(...optionRects.map((r) => r.x));
        const ymin = Math.min(...optionRects.map((r) => r.y));
        const xmax = Math.max(...optionRects.map((r) => r.x + r.w));
        const ymax = Math.max(...optionRects.map((r) => r.y + r.h));
        const union = { x: xmin, y: ymin, w: xmax - xmin, h: ymax - ymin };
        const unionOverlay = srcRectToOverlayRect(union);
        setBoxStyle(roiDragOptions, unionOverlay);

        const sorted = optionRects.slice().sort((a, b) => a.x - b.x);
        const boundaries = sorted.slice(0, 3).map((r) => (r.x + r.w - union.x) * pScale * contain.scale);
        if (roiOptSep1) roiOptSep1.style.left = `${Math.round(boundaries[0] || 0)}px`;
        if (roiOptSep2) roiOptSep2.style.left = `${Math.round(boundaries[1] || 0)}px`;
        if (roiOptSep3) roiOptSep3.style.left = `${Math.round(boundaries[2] || 0)}px`;
      }

      const named = [
        ["possible", roiDragReroll],
        ["count", roiDragCount],
        ["cost", roiDragCost],
      ];
      for (const [label, el] of named) {
        const def = ROI_BOXES.find((b) => b.label === label);
        const xy = session.draft[label];
        if (!def || !xy || !el) continue;
        const rect = scaledRoiRect({ ...def, x: xy.x, y: xy.y }, srcW, srcH);
        setBoxStyle(el, srcRectToOverlayRect(rect));
      }
    }

    async function openRoiAdjustModal() {
      if (!roiAdjustBtn || !roiAdjustModal || !roiAdjustPreviewImg || !roiAdjustPreviewWrap) return;
      if (!screenVideo.videoWidth || !screenVideo.videoHeight) {
        alert("공유 화면 프레임이 없습니다. 화면 공유를 다시 시작해주세요.");
        return;
      }

      const srcW = screenVideo.videoWidth;
      const srcH = screenVideo.videoHeight;
      const resized = fitSize(srcW, srcH, 1600);

      const canvas = document.createElement("canvas");
      canvas.width = resized.width;
      canvas.height = resized.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        alert("Canvas context unavailable.");
        return;
      }
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);

      let url = null;
      try {
        const blob = await canvasToBlob(canvas, "image/jpeg", 0.9);
        url = URL.createObjectURL(blob);
      } catch (_err) {
        alert("미리보기 캡처에 실패했습니다.");
        return;
      }

      const beforeRaw = cloneJson(state.roiOverrides) || null;
      roiAdjustSession = {
        before_raw: beforeRaw,
        draft: buildRoiDraftFromCurrent(beforeRaw),
        src_w: srcW,
        src_h: srcH,
        preview_w: resized.width,
        preview_h: resized.height,
        preview_scale: resized.width / srcW,
        preview_url: url,
      };

      roiAdjustPreviewImg.src = url;
      await new Promise((resolve) => {
        roiAdjustPreviewImg.onload = () => resolve(true);
        roiAdjustPreviewImg.onerror = () => resolve(false);
      });

      roiAdjustModal.classList.remove("hidden");
      roiAdjustModal.classList.add("flex");
      document.body.style.overflow = "hidden";

      requestAnimationFrame(() => {
        renderRoiAdjustOverlay();
      });
    }

    function closeRoiAdjustModal({ apply }) {
      if (!roiAdjustModal) return;
      const session = roiAdjustSession;
      roiAdjustDrag = null;
      roiAdjustSession = null;
      roiAdjustModal.classList.add("hidden");
      roiAdjustModal.classList.remove("flex");
      document.body.style.overflow = "";

      if (session && session.preview_url) {
        try {
          URL.revokeObjectURL(session.preview_url);
        } catch (_err) {
          // ignore
        }
      }

      if (!session) return;
      if (apply) {
        state.roiOverrides = session.draft;
        saveRoiOverridesToStorage(state.roiOverrides);
      } else {
        state.roiOverrides = session.before_raw;
      }
    }

    function onRoiDragPointerDown(ev) {
      const target = ev.currentTarget && ev.currentTarget.dataset ? ev.currentTarget.dataset.drag : null;
      if (!target || !roiAdjustSession) return;
      roiAdjustDrag = {
        target,
        pointerId: ev.pointerId,
        startX: ev.clientX,
        startY: ev.clientY,
        startDraft: cloneJson(roiAdjustSession.draft) || buildRoiDraftFromCurrent(null),
      };
      try {
        ev.currentTarget.setPointerCapture(ev.pointerId);
      } catch (_err) {
        // ignore
      }
      ev.preventDefault();
    }

    function onRoiDragPointerMove(ev) {
      if (!roiAdjustDrag || !roiAdjustSession) return;
      const dx = ev.clientX - roiAdjustDrag.startX;
      const dy = ev.clientY - roiAdjustDrag.startY;
      const { dxBase, dyBase } = roiOverlayDeltaToBaseDelta(dx, dy, roiAdjustSession);
      if (!Number.isFinite(dxBase) || !Number.isFinite(dyBase)) return;

      const next = cloneJson(roiAdjustDrag.startDraft) || {};
      const applyDelta = (label) => {
        if (!next[label]) return;
        next[label] = {
          x: Math.max(0, Math.min(ROI_BASE_WIDTH, Number(next[label].x) + dxBase)),
          y: Math.max(0, Math.min(ROI_BASE_HEIGHT, Number(next[label].y) + dyBase)),
        };
      };

      if (roiAdjustDrag.target === "options") {
        for (const label of ["option1", "option2", "option3", "option4"]) {
          applyDelta(label);
        }
      } else {
        applyDelta(roiAdjustDrag.target);
      }

      roiAdjustSession.draft = next;
      renderRoiAdjustOverlay();
      ev.preventDefault();
    }

    function onRoiDragPointerUp(_ev) {
      roiAdjustDrag = null;
    }

    function bindRoiAdjustControls() {
      if (!roiAdjustBtn || !roiAdjustModal) return;
      if (roiAdjustBtn.dataset.bound === "1") return;
      roiAdjustBtn.dataset.bound = "1";

      roiAdjustBtn.addEventListener("click", openRoiAdjustModal);

      if (roiAdjustCancelBtn) {
        roiAdjustCancelBtn.addEventListener("click", () => closeRoiAdjustModal({ apply: false }));
      }
      if (roiAdjustApplyBtn) {
        roiAdjustApplyBtn.addEventListener("click", () => closeRoiAdjustModal({ apply: true }));
      }

      // backdrop click -> cancel
      roiAdjustModal.addEventListener("click", (ev) => {
        if (ev.target === roiAdjustModal) {
          closeRoiAdjustModal({ apply: false });
        }
      });

      window.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape" && roiAdjustSession) {
          closeRoiAdjustModal({ apply: false });
        }
      });

      const draggables = [roiDragOptions, roiDragReroll, roiDragCount, roiDragCost].filter(Boolean);
      for (const el of draggables) {
        el.addEventListener("pointerdown", onRoiDragPointerDown);
        el.addEventListener("pointermove", onRoiDragPointerMove);
        el.addEventListener("pointerup", onRoiDragPointerUp);
        el.addEventListener("pointercancel", onRoiDragPointerUp);
      }

      if (roiAdjustPreviewWrap) {
        // Re-render on resize to keep overlay aligned.
        const ro = new ResizeObserver(() => {
          if (roiAdjustSession) renderRoiAdjustOverlay();
        });
        ro.observe(roiAdjustPreviewWrap);
      }
    }

				    async function analyzeCapture() {
		      if (!state.stream) {
		        return;
		      }
			      analyzeBtn.disabled = true;
			      state.successProb = null;
			      state.lastError = null;

				      try {
				        const tCapture0 = performance.now();
				        const formData = new FormData();
		            if (state.clientId) {
		              formData.append("client_id", String(state.clientId));
		            }
		            const manualOverrides = {};
                const optionOverridePayload =
                  state.uiOverride?.options &&
                  state.optionOverrides &&
                  typeof state.optionOverrides === "object" &&
                  Object.keys(state.optionOverrides).length
                    ? JSON.stringify(state.optionOverrides)
                    : "";
		            if (state.uiOverride?.rerolls) {
		              const v = Math.max(0, Math.min(5, asInt(state.uiState?.rerolls, 0)));
		              formData.append("override_rerolls", String(v));
		              manualOverrides.rerolls = v;
		            }
		            if (state.uiOverride?.attempts_left) {
		              const v = Math.max(0, Math.min(9, asInt(state.uiState?.attempts_left, 0)));
		              formData.append("override_attempts_left", String(v));
		              manualOverrides.attempts_left = v;
		            }
		            if (state.uiOverride?.cost_state) {
		              const v = Math.max(-1, Math.min(1, asInt(state.uiState?.cost_state, 0)));
		              formData.append("override_cost_state", String(v));
		              manualOverrides.cost_state = v;
		            }
                if (optionOverridePayload) {
                  formData.append("override_options_json", optionOverridePayload);
                  manualOverrides.options = Object.keys(state.optionOverrides).map((k) => asInt(k, -1)).filter((v) => v >= 0);
                }
				        let captureMode = CAPTURE_PIPELINE;
				        let roiSchemaVersion = ROI_SCHEMA_VERSION;
				        let capture = null;
				        let blob = null;
		        let uploadBytes = 0;
		        let roiLabels = [];
		        let roiCount = 0;
		        let roiRects = [];
		        try {
		          capture = await captureMultiCropPayload();
		          const ts = Date.now();
		          for (const roi of capture.rois) {
		            formData.append(`roi_${roi.label}`, roi.blob, `${roi.label}_${ts}.png`);
		            uploadBytes += roi.blob?.size || 0;
		            roiLabels.push(roi.label);
		            roiRects.push({
		              label: roi.label,
		              w: roi.rect.w,
		              h: roi.rect.h,
		              bytes: roi.blob?.size || 0,
		            });
		          }
		          roiCount = capture.rois.length;
		        } catch (_multiCropErr) {
		          captureMode = FALLBACK_CAPTURE_PIPELINE;
		          roiSchemaVersion = FALLBACK_ROI_SCHEMA_VERSION;
		          capture = await captureVideoFrameBlob();
		          blob = capture.blob;
		          const fileName = `capture_${Date.now()}.jpg`;
		          formData.append("image", blob, fileName);
		          uploadBytes = blob?.size || 0;
		        }
			        const tCapture1 = performance.now();
			        formData.append("willpower", String(state.current.willpower));
	        formData.append("points", String(state.current.points));
	        formData.append("effect1_level", String(state.current.effect1_level));
	        formData.append("effect2_level", String(state.current.effect2_level));
			        formData.append("target_willpower", String(state.target.willpower));
			        formData.append("target_points", String(state.target.points));
		        formData.append("target_effect1_level", String(state.target.effect1_level));
		        formData.append("target_effect2_level", String(state.target.effect2_level));
	            formData.append("role", String(state.uiState?.role || "dealer"));
	            formData.append("gem_type", String(state.uiState?.gem_type || "stable"));
	            formData.append("roi_schema_version", roiSchemaVersion);
				        formData.append(
				          "client_debug",
				          JSON.stringify({
				            capture_ms: Math.round((tCapture1 - tCapture0) * 100) / 100,
		                capture_pipeline: captureMode,
		                roi_schema_version: roiSchemaVersion,
			            video_w: capture.source_w || screenVideo.videoWidth || null,
			            video_h: capture.source_h || screenVideo.videoHeight || null,
			            upload_w: capture.upload_w || null,
			            upload_h: capture.upload_h || null,
			            upload_bytes: uploadBytes || null,
			            jpeg_quality: capture.jpeg_quality || null,
			            letterbox: capture.letterbox || null,
                    roi_overrides: state.roiOverrides || null,
		                roi_count: roiCount,
		                roi_labels: roiLabels,
		                roi_rects: roiRects,
		                manual_overrides: manualOverrides,
			          })
			        );

			        const res = await fetch("/api/analyze", {
			          method: "POST",
			          body: formData,
		        });
		        const body1 = await res.json().catch(() => ({}));
		        if (!res.ok || !body1.ok) {
		          const detail =
		            body1?.detail || body1?.error || (Object.keys(body1 || {}).length ? JSON.stringify(body1) : "");
		          const suffix = detail ? `: ${detail}` : (res.statusText ? `: ${res.statusText}` : "");
		          throw new Error(`분석 실패 (HTTP ${res.status})${suffix}`);
		        }

		        let body = body1;
		        let didRetry = false;
		        const countText1 = body1?.ocr_result?.count;
		        const hasCount1 = typeof countText1 === "string" && countText1.includes("/");
		        if (captureMode === CAPTURE_PIPELINE && !hasCount1) {
		          didRetry = true;
		          const tRetry0 = performance.now();
			          const retryForm = new FormData();
			          if (state.clientId) {
			            retryForm.append("client_id", String(state.clientId));
			          }
			          if (state.uiOverride?.rerolls) {
			            retryForm.append("override_rerolls", String(Math.max(0, Math.min(5, asInt(state.uiState?.rerolls, 0)))));
			          }
			          if (state.uiOverride?.attempts_left) {
			            retryForm.append("override_attempts_left", String(Math.max(0, Math.min(9, asInt(state.uiState?.attempts_left, 0)))));
			          }
			          if (state.uiOverride?.cost_state) {
			            retryForm.append("override_cost_state", String(Math.max(-1, Math.min(1, asInt(state.uiState?.cost_state, 0)))));
			          }
                if (optionOverridePayload) {
                  retryForm.append("override_options_json", optionOverridePayload);
                }
			          const retryCapture = await captureVideoFrameBlob();
			          const retryBlob = retryCapture.blob;
			          const retryFileName = `capture_retry_${Date.now()}.jpg`;
			          retryForm.append("image", retryBlob, retryFileName);
		          const tRetry1 = performance.now();
		          retryForm.append("willpower", String(state.current.willpower));
		          retryForm.append("points", String(state.current.points));
		          retryForm.append("effect1_level", String(state.current.effect1_level));
		          retryForm.append("effect2_level", String(state.current.effect2_level));
		          retryForm.append("target_willpower", String(state.target.willpower));
		          retryForm.append("target_points", String(state.target.points));
		          retryForm.append("target_effect1_level", String(state.target.effect1_level));
		          retryForm.append("target_effect2_level", String(state.target.effect2_level));
		          retryForm.append("role", String(state.uiState?.role || "dealer"));
		          retryForm.append("gem_type", String(state.uiState?.gem_type || "stable"));
		          retryForm.append("roi_schema_version", FALLBACK_ROI_SCHEMA_VERSION);
			          retryForm.append(
			            "client_debug",
			            JSON.stringify({
			              capture_ms: Math.round((tRetry1 - tRetry0) * 100) / 100,
			              capture_pipeline: FALLBACK_CAPTURE_PIPELINE,
			              roi_schema_version: FALLBACK_ROI_SCHEMA_VERSION,
			              video_w: retryCapture.source_w || screenVideo.videoWidth || null,
			              video_h: retryCapture.source_h || screenVideo.videoHeight || null,
			              upload_w: retryCapture.upload_w || null,
			              upload_h: retryCapture.upload_h || null,
			              upload_bytes: retryBlob?.size || null,
			              jpeg_quality: retryCapture.jpeg_quality || null,
			              auto_retry: true,
			              retry_reason: "missing_count",
			              retry_of: body1?.record?.id || null,
			              first_capture_pipeline: captureMode,
			              first_roi_schema_version: roiSchemaVersion,
			              first_letterbox: capture?.letterbox || null,
                      roi_overrides: state.roiOverrides || null,
			              manual_overrides: manualOverrides,
			            })
			          );

		          const res2 = await fetch("/api/analyze", {
		            method: "POST",
		            body: retryForm,
		          });
		          const body2 = await res2.json().catch(() => ({}));
		          if (!res2.ok || !body2.ok) {
		            const detail =
		              body2?.detail || body2?.error || (Object.keys(body2 || {}).length ? JSON.stringify(body2) : "");
		            const suffix = detail ? `: ${detail}` : (res2.statusText ? `: ${res2.statusText}` : "");
		            throw new Error(`분석 재시도 실패 (HTTP ${res2.status})${suffix}`);
			          }
			          body = body2;
			        }

			        // If homography fails and the OCR result also looks empty, the shared
			        // screen is likely not the Lost Ark gem-processing UI (wrong window/tab).
			        // Avoid updating the UI with bogus "0/7" -> stop recommendations.
			        try {
			          const hom = body?.debug?.homography;
			          if (hom && hom.ok === false) {
			            const reason = String(hom.reason || "");
			            const optionsLen = Array.isArray(body.ui_state?.options) ? body.ui_state.options.length : 0;
			            const countText = body?.ocr_result?.count;
			            const costVal = body?.ocr_result?.cost;
			            const possVal = body?.ocr_result?.possible;
			            const looksEmpty =
			              optionsLen === 0 && (costVal == null || costVal === 0) && (possVal == null || possVal === 0);
			            const looksBadCount = typeof countText !== "string" || /^\s*0\s*\//.test(countText);
			            const fatalReasons = new Set([
			              "low_inliers",
			              "few_good_matches",
			              "no_target_features",
			              "homography_failed",
			              "missing_rois",
			            ]);
			            if (fatalReasons.has(reason) && looksEmpty && looksBadCount) {
			              state.lastError =
			                "공유한 화면에서 젬 가공 창을 찾지 못했습니다. 로스트아크(젬 가공 화면) 창을 선택해주세요.";
			              return;
			            }
			          }
			        } catch (_err) {
			          // Best-effort guard; never fail analyze because of this check.
			        }

			        state.lastResponse = body;
			        state.successProb = body.goal_success?.success_prob ?? null;
			        const gs = body.goal_success ?? null;
		        if (!gs) {
		          state.lastError = "서버 응답에 성공 확률(goal_success)이 없습니다. 서버를 재시작/업데이트해주세요.";
		        } else if (gs.success_prob == null) {
		          const reason = gs.reason ? String(gs.reason) : "unknown";
		          const errText = gs.error ? `: ${String(gs.error)}` : "";
		          state.lastError = `성공 확률 계산 실패 (${reason}${errText})`;
		        }
			        state.uiState = {
			          rerolls: asInt(body.ui_state?.rerolls, 0),
			          attempts_left: asInt(body.ui_state?.attempts_left, 0),
			          cost_state: asInt(body.ui_state?.cost_state, 0),
		          options: Array.isArray(body.ui_state?.options) ? body.ui_state.options : [],
	            role: String(body.ui_state?.role || state.uiState?.role || "dealer"),
	            gem_type: String(body.ui_state?.gem_type || state.uiState?.gem_type || "stable"),
		        };
            if (optionOverridePayload) {
              state.uiOverride.options = false;
              state.optionOverrides = {};
            }
	        state.ocrCount = body.ocr_result?.count || null;

	        const finalCountText = body?.ocr_result?.count;
	        const hasFinalCount = typeof finalCountText === "string" && finalCountText.includes("/");
	        if (!hasFinalCount && !state.lastError) {
	          const hint = didRetry
	            ? "전체 화면으로 재시도했지만 가공 횟수(count) 인식에 실패했습니다."
	            : "가공 횟수(count) 인식에 실패했습니다.";
	          state.lastError = `${hint} (21:9 화면공유/해상도/UI 스케일을 확인해주세요)`;
	        }
		      } catch (err) {
		        let msg = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
		        if (msg.includes("No screen frame available")) {
		          msg = "공유 화면 프레임이 없습니다. 화면 공유를 다시 시작해주세요.";
		        } else if (msg.includes("Failed to capture frame blob")) {
	          msg = "캡처 프레임 생성에 실패했습니다. 화면 공유를 다시 시작해주세요.";
	        } else if (msg.includes("Failed to fetch")) {
	          msg = "서버 연결에 실패했습니다. 서버가 실행 중인지 확인해주세요.";
	        }
	        state.lastError = msg;
	        console.error(err);
	      } finally {
	        analyzeBtn.disabled = false;
	        renderAll();
	      }
	    }

	    function applyOption(index) {
      const options = Array.isArray(state.uiState.options) ? state.uiState.options : [];
      const opt = options[index];
      if (!opt) return;

      const category = String(opt.category || "").toLowerCase();
      const value = asInt(opt.value, 0);

      if (category === "willpower") {
        state.current.willpower = clampStat(state.current.willpower + value);
      } else if (category === "points") {
        state.current.points = clampStat(state.current.points + value);
      } else if (category === "effect1") {
        if (value !== 0) {
          state.current.effect1_level = clampStat(state.current.effect1_level + value);
        }
      } else if (category === "effect2") {
        if (value !== 0) {
          state.current.effect2_level = clampStat(state.current.effect2_level + value);
        }
      } else if (category === "special") {
        if (isRerollOption(opt)) {
          const gain = Math.max(1, Math.min(2, Math.abs(value || 1)));
          state.uiState.rerolls = Math.max(0, asInt(state.uiState.rerolls, 0) + gain);
        } else if (isCostOption(opt)) {
          const delta = value >= 0 ? 1 : -1;
          state.uiState.cost_state = Math.max(-1, Math.min(1, asInt(state.uiState.cost_state, 0) + delta));
        }
      }

      if (asInt(state.uiState.attempts_left, 0) > 0) {
        state.uiState.attempts_left -= 1;
      }

      state.uiState.options = [];
      state.uiOverride.options = false;
      state.optionOverrides = {};
      state.ocrCount = `${Math.max(0, asInt(state.uiState.attempts_left, 0))}`;
	      renderAll();
	    }

      function bindRoleGemControls() {
        if (roleSelect) {
          roleSelect.addEventListener("change", () => {
            const v = String(roleSelect.value || "").toLowerCase();
            state.uiState.role = v === "support" ? "support" : "dealer";
            renderAll();
          });
        }
        if (gemTypeSelect) {
          gemTypeSelect.addEventListener("change", () => {
            const v = String(gemTypeSelect.value || "").toLowerCase();
            if (v === "solid" || v === "immutable" || v === "stable") {
              state.uiState.gem_type = v;
            } else {
              state.uiState.gem_type = "stable";
            }
            renderAll();
          });
        }
      }

		    function bindStatControls() {
	      document.querySelectorAll("button[data-op]").forEach((btn) => {
	        btn.addEventListener("click", () => {
	          const key = btn.dataset.key;
	          const op = btn.dataset.op;
	          if (!key || !op) return;
	          const targetObj = op.includes("target") ? state.target : state.current;
	          const fallback = op.includes("target") ? 4 : 1;
	          const current = asInt(targetObj[key], fallback);
	          if (op === "inc-current" || op === "inc-target") {
	            targetObj[key] = clampStat(current + 1);
	          } else if (op === "dec-current" || op === "dec-target") {
	            targetObj[key] = clampStat(current - 1);
	          }
	          renderAll();
	        });
	      });

      document.querySelectorAll("input[data-input='current']").forEach((input) => {
        input.addEventListener("change", () => {
          const key = input.dataset.key;
          if (!key) return;
          state.current[key] = clampStat(input.value);
          renderAll();
        });
      });

      document.querySelectorAll("input[data-input='target']").forEach((input) => {
        input.addEventListener("change", () => {
          const key = input.dataset.key;
          if (!key) return;
          state.target[key] = clampStat(input.value);
          renderAll();
        });
      });
    }

		    shareStartBtn.addEventListener("click", startShare);
		    shareStopBtn.addEventListener("click", stopShare);
			    analyzeBtn.addEventListener("click", analyzeCapture);
			    resetBtn.addEventListener("click", resetGemState);
	    if (bugReportSendBtn) {
	      bugReportSendBtn.addEventListener("click", submitBugReport);
	    }
		        bindRoleGemControls();
				    bindStatControls();
		        bindSummaryAdjustControls();
	          bindRoiAdjustControls();
	          bindOptionPickerControls();
		        renderNoticeItems(DEFAULT_NOTICE_ITEMS);
		        loadNotice();
	        refreshServerStatus();
	        setInterval(refreshServerStatus, 30000);
			    setSharingUI(false);
			    renderAll();
  </script>
</body>
</html>
