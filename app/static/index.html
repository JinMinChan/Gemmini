<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>젬미나이</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-1: #0a1422;
      --bg-2: #1d2f44;
      --card: #0f1f2f;
      --line: #2f516f;
      --line-soft: #23415b;
      --accent-gold: #ffd166;
      --accent-cyan: #6ee7f7;
      --accent-green: #89f59d;
      --accent-red: #ff8b8b;
      --text-main: #eef5ff;
      --text-sub: #b9c9dc;

      /* category colors (from gem_prog.py) */
      --stat-will: #ff5a3c;
      --stat-point: #f5c542;
      --stat-eff1: #6bff4a;
      --stat-eff2: #4fd6ff;
      --stat-special: #aaaaaa;
    }

    body {
      font-family: "Exo 2", sans-serif;
      color: var(--text-main);
      background:
        radial-gradient(circle at 8% 12%, rgba(110, 231, 247, 0.16), transparent 30%),
        radial-gradient(circle at 92% 82%, rgba(255, 209, 102, 0.12), transparent 34%),
        linear-gradient(130deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    .panel {
      background: linear-gradient(170deg, rgba(15, 31, 47, 0.93), rgba(10, 21, 35, 0.9));
      border: 1px solid var(--line);
      box-shadow: 0 12px 36px rgba(1, 9, 17, 0.36);
      border-radius: 1rem;
    }

    .halo {
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 0 40px rgba(110, 231, 247, 0.08);
      border-radius: 1rem;
    }

    .glow-btn {
      transition: transform 140ms ease, box-shadow 140ms ease, opacity 140ms ease;
    }

    .glow-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 22px rgba(110, 231, 247, 0.26);
    }

    .glow-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

	    .diamond-shell {
	      --dia-border: var(--line-soft);
	      --dia-accent: var(--accent-cyan);
	      --dia-tint: rgba(110, 231, 247, 0.12);
		      width: clamp(7.25rem, 15vw, 9.5rem);
		      height: clamp(7.25rem, 15vw, 9.5rem);
		      transform: rotate(45deg);
		      border: 1px solid var(--dia-border);
		      border-radius: 1.25rem;
      background:
        radial-gradient(circle at 18% 18%, var(--dia-tint), transparent 62%),
        linear-gradient(140deg, rgba(32, 53, 73, 0.84), rgba(12, 26, 40, 0.9));
      box-shadow: inset 0 0 34px var(--dia-tint);
	      overflow: hidden;
	    }

		    .diamond-stage {
		      width: clamp(19rem, 42vw, 26rem);
		      height: clamp(19rem, 42vw, 26rem);
		    }

    .diamond-shell .stat-name {
      color: var(--dia-accent);
    }

    .diamond-shell .mini-control {
      border-color: var(--dia-border);
    }

    .diamond-shell .stat-input {
      border-color: var(--dia-border);
    }

    .diamond-will {
      --dia-border: rgba(255, 90, 60, 0.55);
      --dia-accent: var(--stat-will);
      --dia-tint: rgba(255, 90, 60, 0.14);
    }

    .diamond-point {
      --dia-border: rgba(245, 197, 66, 0.55);
      --dia-accent: var(--stat-point);
      --dia-tint: rgba(245, 197, 66, 0.12);
    }

    .diamond-eff1 {
      --dia-border: rgba(107, 255, 74, 0.55);
      --dia-accent: var(--stat-eff1);
      --dia-tint: rgba(107, 255, 74, 0.12);
    }

    .diamond-eff2 {
      --dia-border: rgba(79, 214, 255, 0.55);
      --dia-accent: var(--stat-eff2);
      --dia-tint: rgba(79, 214, 255, 0.12);
    }

	    .diamond-inner {
	      width: 100%;
	      height: 100%;
	      transform: rotate(-45deg);
	      display: flex;
	      flex-direction: column;
	      align-items: center;
	      justify-content: center;
	      gap: 0.3rem;
	      padding: 0.3rem clamp(0.5rem, 1.8vw, 0.8rem);
	    }

	    .mini-control {
	      width: clamp(1.1rem, 3.8vw, 1.45rem);
	      height: clamp(1.1rem, 3.8vw, 1.45rem);
	      border-radius: 0.4rem;
	      border: 1px solid #446b8c;
	      color: #d8ecff;
	      background: rgba(36, 60, 80, 0.9);
      font-weight: 700;
      line-height: 1;
    }

    .stat-input {
      width: clamp(1.85rem, 4.6vw, 2.3rem);
      border-radius: 0.45rem;
      border: 1px solid #3f5f7d;
      background: rgba(11, 24, 37, 0.9);
      color: #dff2ff;
      text-align: center;
      font-weight: 700;
    }

    .selector-card {
      border: 1px solid rgba(101, 168, 218, 0.45);
      border-radius: 0.65rem;
      background: linear-gradient(160deg, rgba(20, 44, 67, 0.82), rgba(12, 26, 43, 0.86));
      padding: 0.55rem 0.65rem;
    }

    .selector-select {
      width: 100%;
      border-radius: 0.5rem;
      border: 1px solid #3f5f7d;
      background: rgba(11, 24, 37, 0.95);
      color: #dff2ff;
      font-weight: 600;
      font-size: 0.82rem;
      padding: 0.35rem 0.45rem;
      outline: none;
    }

    /* Hide number input spinners (we use +/- buttons instead). */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    .option-card {
      --opt-border: #2b4c68;
      --opt-hover: #64d8ee;
      --opt-glow: rgba(110, 231, 247, 0.2);
      --opt-tint: rgba(110, 231, 247, 0.12);
      border: 1px solid var(--opt-border);
      background:
        radial-gradient(circle at 18% 18%, var(--opt-tint), transparent 62%),
        linear-gradient(160deg, rgba(20, 44, 67, 0.9), rgba(12, 26, 43, 0.92));
      color: #dcefff;
      border-radius: 0.9rem;
      min-height: 4.35rem;
      transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
    }

    .option-card:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: var(--opt-hover);
      box-shadow: 0 7px 18px var(--opt-glow);
    }

    .option-card:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .opt-will {
      --opt-border: rgba(255, 90, 60, 0.45);
      --opt-hover: var(--stat-will);
      --opt-glow: rgba(255, 90, 60, 0.22);
      --opt-tint: rgba(255, 90, 60, 0.16);
    }

    .opt-point {
      --opt-border: rgba(245, 197, 66, 0.45);
      --opt-hover: var(--stat-point);
      --opt-glow: rgba(245, 197, 66, 0.22);
      --opt-tint: rgba(245, 197, 66, 0.14);
    }

    .opt-eff1 {
      --opt-border: rgba(107, 255, 74, 0.45);
      --opt-hover: var(--stat-eff1);
      --opt-glow: rgba(107, 255, 74, 0.22);
      --opt-tint: rgba(107, 255, 74, 0.14);
    }

    .opt-eff2 {
      --opt-border: rgba(79, 214, 255, 0.45);
      --opt-hover: var(--stat-eff2);
      --opt-glow: rgba(79, 214, 255, 0.22);
      --opt-tint: rgba(79, 214, 255, 0.14);
    }

    .opt-special {
      --opt-border: rgba(170, 170, 170, 0.35);
      --opt-hover: var(--stat-special);
      --opt-glow: rgba(170, 170, 170, 0.2);
      --opt-tint: rgba(170, 170, 170, 0.12);
    }
  </style>
</head>
<body>
  <main class="mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
    <header class="panel p-4 sm:p-5">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <div>
          <h1 class="text-2xl font-extrabold tracking-tight text-sky-100">젬미나이</h1>
          <p class="mt-1 text-sm text-slate-300">게임 창을 공유한 뒤 <span class="font-semibold text-cyan-300">젬미나이</span>를 누르면 추천 행동이 표시됩니다. 가공 후 옵션을 선택해주세요.</p>
        </div>
        <div class="flex flex-wrap gap-2">
          <button id="shareStartBtn" class="glow-btn rounded-lg border border-cyan-400/50 bg-cyan-400/15 px-4 py-2 text-sm font-semibold text-cyan-100">
            화면 공유 시작
          </button>
          <button id="shareStopBtn" class="glow-btn rounded-lg border border-slate-500/60 bg-slate-500/15 px-4 py-2 text-sm font-semibold text-slate-200" disabled>
            공유 중지
          </button>
        </div>
      </div>
      <div class="mt-3 flex flex-wrap items-center gap-x-6 gap-y-2 text-sm">
        <div>
          연결 상태:
          <span id="shareStatus" class="ml-1 font-semibold text-rose-300">공유 안함</span>
        </div>
      </div>
    </header>

    <section class="mt-5 grid gap-4 lg:grid-cols-[1.1fr_1fr]">
      <div class="panel p-4">
        <h2 class="text-lg font-bold text-sky-100">공유 화면</h2>
        <p class="mt-1 text-xs text-slate-300">공유화면 아래 설정에 게임 창을 선택해주세요.</p>
        <div class="halo mt-3 p-3">
          <video id="screenVideo" class="h-[18rem] w-full rounded-xl border border-slate-700/80 bg-slate-950 object-contain sm:h-[22rem]" autoplay muted playsinline></video>
        </div>
        <div class="mt-4 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
          <div class="text-sm font-semibold text-sky-100">버그 제보하기</div>
          <p class="mt-1 text-xs text-slate-300">버그나 개선점을 제보해주시면 감사하겠습니다!</p>
          <textarea
            id="bugReportInput"
            class="mt-2 h-24 w-full rounded-md border border-slate-700 bg-slate-950/85 px-3 py-2 text-sm text-slate-100 outline-none focus:border-cyan-400/70"
            placeholder="예: 리롤 2회인데 3회로 표시됩니다."
          ></textarea>
          <div class="mt-2 flex items-center justify-between gap-2">
            <button
              id="bugReportSendBtn"
              class="glow-btn rounded-lg border border-cyan-400/60 bg-cyan-400/15 px-3 py-2 text-xs font-semibold text-cyan-100"
            >
              보내기
            </button>
            <div id="bugReportStatus" class="hidden text-xs"></div>
          </div>
        </div>
      </div>

      <div class="panel p-4">
        <div class="flex flex-wrap items-center justify-between gap-3">
          <h2 class="text-lg font-bold text-sky-100">젬 상태</h2>
          <div class="text-sm text-slate-300">
            현재 합계: <span id="currentSum" class="font-bold text-cyan-200">4</span> /
            목표 합계: <span id="targetSum" class="font-bold text-amber-200">16</span>
          </div>
        </div>
        <p class="mt-1 text-xs text-slate-300">실제 게임에서 적용된 옵션을 눌러 현재 스탯에 반영하세요.</p>

        <div class="mt-3 grid gap-2 sm:grid-cols-2">
          <label class="selector-card">
            <div class="text-[11px] font-semibold uppercase tracking-wide text-slate-300">역할</div>
            <select id="roleSelect" class="selector-select mt-1">
              <option value="dealer">딜러</option>
              <option value="support">서폿</option>
            </select>
          </label>
          <label class="selector-card">
            <div class="text-[11px] font-semibold uppercase tracking-wide text-slate-300">젬 종류</div>
            <select id="gemTypeSelect" class="selector-select mt-1">
              <option value="stable">안정/침식</option>
              <option value="solid">견고/왜곡</option>
              <option value="immutable">불변/붕괴</option>
            </select>
          </label>
        </div>

        <div class="halo mt-3 p-3 sm:p-4">
			          <div class="diamond-stage relative mx-auto max-w-full">
		            <div class="absolute left-1/2 top-5 -translate-x-1/2">
	              <div class="diamond-shell diamond-will">
	                <div class="diamond-inner" data-stat="willpower">
                  <div class="stat-name text-xs font-semibold">의지력</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="willpower">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="willpower" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="willpower">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="willpower">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="willpower" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="willpower">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute left-5 top-1/2 -translate-y-1/2">
	              <div class="diamond-shell diamond-eff1">
	                <div class="diamond-inner" data-stat="effect1_level">
                  <div class="stat-name text-xs font-semibold">부옵션1</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="effect1_level">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="effect1_level" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="effect1_level">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="effect1_level">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="effect1_level" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="effect1_level">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute right-5 top-1/2 -translate-y-1/2">
	              <div class="diamond-shell diamond-eff2">
	                <div class="diamond-inner" data-stat="effect2_level">
                  <div class="stat-name text-xs font-semibold">부옵션2</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="effect2_level">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="effect2_level" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="effect2_level">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="effect2_level">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="effect2_level" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="effect2_level">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute bottom-5 left-1/2 -translate-x-1/2">
              <div class="diamond-shell diamond-point">
                <div class="diamond-inner" data-stat="points">
                  <div class="stat-name text-xs font-semibold">질서/혼돈</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="points">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="points" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="points">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="points">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="points" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="points">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>
          </div>
        </div>

	        <div class="mt-4 grid grid-cols-2 gap-2 sm:grid-cols-4">
	          <button id="resetBtn" class="glow-btn rounded-lg border border-rose-400/60 bg-rose-400/15 px-4 py-3 text-sm font-bold text-rose-100">
	            초기화
	          </button>
	          <div class="hidden sm:block"></div>
	          <div class="hidden sm:block"></div>
	          <button id="analyzeBtn" class="glow-btn rounded-lg border border-amber-300/60 bg-amber-300/20 px-4 py-3 text-sm font-bold text-amber-100" disabled>
	            젬미나이
	          </button>
	        </div>

	        <div id="analyzeError" class="mt-2 hidden rounded-lg border border-rose-400/40 bg-rose-400/10 px-3 py-2 text-xs text-rose-100"></div>

	        <div id="optionsGrid" class="mt-2 grid grid-cols-2 gap-2 sm:grid-cols-4"></div>

        <div class="mt-4 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
          <div class="text-xs font-semibold uppercase tracking-wide text-slate-400">추천 행동</div>
          <div id="actionCard" class="mt-2 grid grid-cols-1 overflow-hidden rounded-md border border-slate-700 bg-slate-950/85">
            <div class="px-3 py-3 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">추천</div>
              <div id="actionText" class="mt-1 text-lg font-extrabold text-slate-200">-</div>
            </div>
            <div class="border-t border-slate-800/80 px-3 py-3 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">성공 확률</div>
              <div id="successProbText" class="mt-1 text-lg font-extrabold text-rose-200">-</div>
            </div>
          </div>
          <div class="mt-3 grid grid-cols-3 gap-2">
            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">리롤</div>
              <div id="rerollsText" class="text-lg font-bold text-slate-100">-</div>
            </div>
            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">가공횟수</div>
              <div id="countText" class="text-lg font-bold text-slate-100">-</div>
            </div>
            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">가공비용</div>
              <div id="costText" class="text-lg font-bold text-slate-100">-</div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
			    const shareStartBtn = document.getElementById("shareStartBtn");
			    const shareStopBtn = document.getElementById("shareStopBtn");
				    const analyzeBtn = document.getElementById("analyzeBtn");
				    const resetBtn = document.getElementById("resetBtn");
				    const screenVideo = document.getElementById("screenVideo");
			    const bugReportInput = document.getElementById("bugReportInput");
			    const bugReportSendBtn = document.getElementById("bugReportSendBtn");
			    const bugReportStatus = document.getElementById("bugReportStatus");
				    const analyzeError = document.getElementById("analyzeError");
	          const roleSelect = document.getElementById("roleSelect");
	          const gemTypeSelect = document.getElementById("gemTypeSelect");

    const shareStatus = document.getElementById("shareStatus");
    const actionText = document.getElementById("actionText");
    const successProbText = document.getElementById("successProbText");
    const rerollsText = document.getElementById("rerollsText");
    const countText = document.getElementById("countText");
    const costText = document.getElementById("costText");
    const optionsGrid = document.getElementById("optionsGrid");

	    const currentSumEl = document.getElementById("currentSum");
	    const targetSumEl = document.getElementById("targetSum");

        function makeDefaultUiState(overrides = {}) {
          return {
            rerolls: 0,
            attempts_left: 0,
            cost_state: 0,
            options: [],
            role: "dealer",
            gem_type: "stable",
            ...overrides,
          };
        }

		    const state = {
		      stream: null,
	      current: {
	        willpower: 1,
	        points: 1,
	        effect1_level: 1,
	        effect2_level: 1,
	      },
		      target: {
		        willpower: 4,
		        points: 4,
		        effect1_level: 4,
		        effect2_level: 4,
		      },
		      uiState: makeDefaultUiState(),
		      ocrCount: null,
			      lastResponse: null,
			      successProb: null,
			      lastError: null,
			    };

		    function resetGemState() {
		      state.current = {
		        willpower: 1,
		        points: 1,
		        effect1_level: 1,
		        effect2_level: 1,
		      };
		      state.uiState = makeDefaultUiState({
            role: state.uiState?.role || "dealer",
            gem_type: state.uiState?.gem_type || "stable",
          });
		      state.ocrCount = null;
			      state.lastResponse = null;
			      state.successProb = null;
		      state.lastError = null;
		      renderAll();
		    }

	    function clampStat(v) {
	      const n = Number(v);
	      if (!Number.isFinite(n)) return 1;
	      return Math.max(1, Math.min(5, Math.round(n)));
	    }

    function asInt(v, fallback = 0) {
      const n = Number(v);
      return Number.isFinite(n) ? Math.trunc(n) : fallback;
    }

    function costFromState(costState) {
      if (costState <= -1) return 0;
      if (costState === 0) return 900;
      if (costState >= 1) return 1800;
      return 900;
    }

    function actionKo(actionName) {
      if (!actionName) return "-";
      const map = {
        process: "가공",
        reroll: "리롤",
        stop: "가공 중단",
      };
      return map[actionName] || actionName;
    }

    function textOfOption(opt) {
      if (!opt) return "옵션 없음";
      return String(opt.text || opt.formatted || opt.option || opt.raw_option || "옵션 없음");
    }

    function escapeHtml(text) {
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function optionBlob(opt) {
      return [
        opt?.text || "",
        opt?.formatted || "",
        opt?.raw_option || "",
        opt?.option || "",
      ].join(" ").toLowerCase();
    }

    function isRerollOption(opt) {
      const blob = optionBlob(opt);
      return blob.includes("reroll") || blob.includes("다른 항목") || blob.includes("항목 보기");
    }

    function isCostOption(opt) {
      const blob = optionBlob(opt);
      return blob.includes("cost") || blob.includes("비용");
    }

    function renderStatInputs() {
      document.querySelectorAll("input[data-input='current']").forEach((el) => {
        const key = el.dataset.key;
        el.value = String(state.current[key]);
      });
      document.querySelectorAll("input[data-input='target']").forEach((el) => {
        const key = el.dataset.key;
        el.value = String(state.target[key]);
      });
    }

	    function renderSums() {
	      const currentSum = Object.values(state.current).reduce((acc, v) => acc + asInt(v, 1), 0);
	      const targetSum = Object.values(state.target).reduce((acc, v) => acc + asInt(v, 4), 0);
	      currentSumEl.textContent = String(currentSum);
	      targetSumEl.textContent = String(targetSum);
	    }

      function renderRoleGemSelectors() {
        if (roleSelect) {
          roleSelect.value = String(state.uiState?.role || "dealer");
        }
        if (gemTypeSelect) {
          gemTypeSelect.value = String(state.uiState?.gem_type || "stable");
        }
      }

    function renderOptions() {
      const options = Array.isArray(state.uiState.options) ? state.uiState.options : [];
      const normalized = options.slice(0, 4);
      while (normalized.length < 4) {
        normalized.push(null);
      }

      optionsGrid.innerHTML = normalized.map((opt, idx) => {
        const label = escapeHtml(textOfOption(opt));
        const styleClass = optionStyleClass(opt);
        return `
          <button class="option-card ${styleClass} p-3 text-left text-sm font-semibold" ${opt ? "" : "disabled"} data-option-idx="${idx}">
            <div class="text-xs uppercase tracking-wide text-slate-400">옵션 ${idx + 1}</div>
            <div class="mt-1 leading-snug">${label}</div>
          </button>
        `;
      }).join("");

      optionsGrid.querySelectorAll("[data-option-idx]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const idx = asInt(btn.dataset.optionIdx, -1);
          if (idx < 0) return;
          applyOption(idx);
        });
      });
    }

    function renderSummaryPanels() {
      rerollsText.textContent = String(asInt(state.uiState.rerolls, 0));
      const countDisplay = state.ocrCount || (state.uiState.attempts_left != null ? `${asInt(state.uiState.attempts_left, 0)}` : "-");
      countText.textContent = countDisplay;
      costText.textContent = `${costFromState(asInt(state.uiState.cost_state, 0))}G`;
    }

    function optionStyleClass(opt) {
      const category = String(opt?.category || "").toLowerCase();
      if (category === "willpower") return "opt-will";
      if (category === "points") return "opt-point";
      if (category === "effect1" || category === "effect1_level") return "opt-eff1";
      if (category === "effect2" || category === "effect2_level") return "opt-eff2";
      if (category === "special") return "opt-special";
      return "opt-special";
    }

    function renderAction(rl) {
      if (!rl || !rl.action_name) {
        actionText.textContent = "-";
        actionText.className = "mt-1 text-lg font-extrabold text-slate-200";
        return;
      }

      const action = String(rl.action_name);
      const actionNameKo = actionKo(action);
      actionText.textContent = actionNameKo;

      if (action === "process") {
        actionText.className = "mt-1 text-lg font-extrabold text-emerald-300";
      } else if (action === "reroll") {
        actionText.className = "mt-1 text-lg font-extrabold text-cyan-300";
      } else {
        actionText.className = "mt-1 text-lg font-extrabold text-amber-300";
      }
    }

	    function renderSuccessProb() {
	      if (state.successProb == null) {
	        successProbText.textContent = "-";
	        return;
	      }

	      const p = Number(state.successProb);
	      if (!Number.isFinite(p)) {
	        successProbText.textContent = "-";
	        return;
	      }

	      const pct = Math.max(0, Math.min(1, p)) * 100;
	      if (pct > 0 && pct < 0.1) {
	        successProbText.textContent = "<0.1%";
	        return;
	      }
	      if (pct < 1) {
	        successProbText.textContent = `${pct.toFixed(2)}%`;
	        return;
	      }
	      successProbText.textContent = `${pct.toFixed(1)}%`;
	    }

		    function renderAll() {
		      renderStatInputs();
		      renderSums();
          renderRoleGemSelectors();
		      renderSummaryPanels();
		      renderOptions();
		      renderAction(state.lastResponse?.rl || null);
	      renderSuccessProb();
	      renderError();
	    }

		    function renderError() {
		      if (!analyzeError) return;
		      const msg = state.lastError ? String(state.lastError) : "";
		      if (!msg) {
		        analyzeError.textContent = "";
	        analyzeError.classList.add("hidden");
	        return;
	      }
		      analyzeError.textContent = msg;
		      analyzeError.classList.remove("hidden");
		    }

	    function setBugReportStatus(message, tone = "info") {
	      if (!bugReportStatus) return;
	      const text = String(message || "").trim();
	      if (!text) {
	        bugReportStatus.textContent = "";
	        bugReportStatus.className = "hidden text-xs";
	        return;
	      }
	      let cls = "text-slate-300";
	      if (tone === "ok") cls = "text-emerald-300";
	      if (tone === "error") cls = "text-rose-300";
	      bugReportStatus.textContent = text;
	      bugReportStatus.className = `text-xs ${cls}`;
	    }

	    async function submitBugReport() {
	      if (!bugReportInput || !bugReportSendBtn) return;
	      const message = String(bugReportInput.value || "").trim();
	      if (!message) {
	        setBugReportStatus("내용을 입력해주세요.", "error");
	        return;
	      }

	      bugReportSendBtn.disabled = true;
	      setBugReportStatus("전송 중...", "info");
	      try {
	        const fd = new FormData();
	        fd.append("message", message);
	        const recordId = state.lastResponse?.record?.id;
	        if (recordId) {
	          fd.append("record_id", String(recordId));
	        }
	        const res = await fetch("/api/report", {
	          method: "POST",
	          body: fd,
	        });
	        const body = await res.json().catch(() => ({}));
	        if (!res.ok || !body.ok) {
	          const detail = body?.detail || body?.error || res.statusText || "unknown";
	          throw new Error(`제보 저장 실패: ${detail}`);
	        }
	        bugReportInput.value = "";
	        setBugReportStatus("제보가 저장되었습니다. 감사합니다!", "ok");
	      } catch (err) {
	        const msg = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
	        setBugReportStatus(msg || "제보 전송 실패", "error");
	      } finally {
	        bugReportSendBtn.disabled = false;
	      }
	    }

	    function setSharingUI(isSharing) {
	      shareStartBtn.disabled = isSharing;
      shareStopBtn.disabled = !isSharing;
      analyzeBtn.disabled = !isSharing;
      shareStatus.textContent = isSharing ? "공유 중" : "공유 안함";
      shareStatus.className = `ml-1 font-semibold ${isSharing ? "text-emerald-300" : "text-rose-300"}`;
    }

    async function startShare() {
      if (!navigator.mediaDevices?.getDisplayMedia) {
        alert("이 브라우저는 화면 공유 API를 지원하지 않습니다.");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: { frameRate: 15 },
          audio: false,
        });
        state.stream = stream;
        screenVideo.srcObject = stream;
        screenVideo.play().catch(() => {});

        const track = stream.getVideoTracks()[0];
        if (track) {
          track.addEventListener("ended", () => {
            stopShare();
          });
        }

        setSharingUI(true);
      } catch (err) {
        setSharingUI(false);
        shareStatus.textContent = "공유 실패";
        shareStatus.className = "ml-1 font-semibold text-rose-300";
      }
    }

    function stopShare() {
      if (state.stream) {
        state.stream.getTracks().forEach((t) => t.stop());
      }
      state.stream = null;
      screenVideo.srcObject = null;
      setSharingUI(false);
    }

    const ROI_SCHEMA_VERSION = "screen_v2_multicrop";
    const CAPTURE_PIPELINE = "multi_crop_png";
    const FALLBACK_ROI_SCHEMA_VERSION = "screen_v1";
    const FALLBACK_CAPTURE_PIPELINE = "fullframe_resized_jpeg";
    const ROI_BASE_WIDTH = 2560;
    const ROI_BASE_HEIGHT = 1440;
    const ROI_BOXES = [
      { label: "option1", x: 1043.72, y: 793.61, w: 150.71, h: 112.23 },
      { label: "option2", x: 1197.63, y: 795.22, w: 147.50, h: 105.81 },
      { label: "option3", x: 1360.36, y: 796.02, w: 158.72, h: 113.83 },
      { label: "option4", x: 1512.67, y: 795.22, w: 152.31, h: 109.02 },
      { label: "possible", x: 1669.79, y: 794.41, w: 126.66, h: 59.32 },
      { label: "cost", x: 1579.21, y: 887.40, w: 96.20, h: 52.91 },
      { label: "count", x: 1476.60, y: 1022.08, w: 64.13, h: 49.70 },
    ];
    const CAPTURE_MAX_LONG_EDGE = 1920;
    const CAPTURE_TARGET_BYTES = 1_600_000; // ~1.6MB
    const CAPTURE_INITIAL_JPEG_QUALITY = 0.86;
    const CAPTURE_MIN_JPEG_QUALITY = 0.62;

    function fitSize(width, height, maxLongEdge) {
      const w = Math.max(1, asInt(width, 1));
      const h = Math.max(1, asInt(height, 1));
      const longEdge = Math.max(w, h);
      if (longEdge <= maxLongEdge) return { width: w, height: h };
      const scale = maxLongEdge / longEdge;
      return {
        width: Math.max(1, Math.round(w * scale)),
        height: Math.max(1, Math.round(h * scale)),
      };
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("Failed to capture frame blob."));
            return;
          }
          resolve(blob);
        }, type, quality);
      });
    }

	    function scaledRoiRect(box, srcW, srcH) {
	      // If the captured video is not the same aspect ratio as the ROI schema
	      // (e.g. 21:9 ultrawide), the game UI is typically centered with extra
	      // horizontal content. Map ROI coordinates onto the centered base-aspect
	      // content rect instead of stretching across the full frame.
	      const baseAspect = ROI_BASE_WIDTH / ROI_BASE_HEIGHT;
	      const srcAspect = srcW / srcH;
	      const eps = 0.02; // tolerate small rounding differences
	      let contentX = 0;
	      let contentY = 0;
	      let contentW = srcW;
	      let contentH = srcH;
	      let letterboxMode = "direct";
	      if (Number.isFinite(srcAspect) && srcAspect > 0 && Math.abs(srcAspect - baseAspect) > eps) {
	        if (srcAspect > baseAspect) {
	          // wider than base -> crop horizontally (use centered 16:9 region)
	          contentW = Math.max(1, Math.round(srcH * baseAspect));
	          contentH = srcH;
	          contentX = Math.max(0, Math.round((srcW - contentW) / 2));
	          contentY = 0;
	          letterboxMode = "crop_x";
	        } else {
	          // taller than base -> crop vertically
	          contentW = srcW;
	          contentH = Math.max(1, Math.round(srcW / baseAspect));
	          contentX = 0;
	          contentY = Math.max(0, Math.round((srcH - contentH) / 2));
	          letterboxMode = "crop_y";
	        }
	      }

	      const scaleX = contentW / ROI_BASE_WIDTH;
	      const scaleY = contentH / ROI_BASE_HEIGHT;
	      const cx = contentX + box.x * scaleX;
	      const cy = contentY + box.y * scaleY;
	      const bw = Math.max(1, Math.round(box.w * scaleX));
	      const bh = Math.max(1, Math.round(box.h * scaleY));

	      const x1 = Math.max(0, Math.floor(cx - bw / 2));
	      const y1 = Math.max(0, Math.floor(cy - bh / 2));
	      const x2 = Math.min(srcW, Math.ceil(cx + bw / 2));
	      const y2 = Math.min(srcH, Math.ceil(cy + bh / 2));

	      return {
	        x: x1,
	        y: y1,
	        w: Math.max(1, x2 - x1),
	        h: Math.max(1, y2 - y1),
	        letterbox: {
	          mode: letterboxMode,
	          content_x: contentX,
	          content_y: contentY,
	          content_w: contentW,
	          content_h: contentH,
	          src_aspect: Math.round((srcAspect || 0) * 1000) / 1000,
	          base_aspect: Math.round(baseAspect * 1000) / 1000,
	        },
	      };
	    }

	    async function captureMultiCropPayload() {
	      if (!screenVideo.videoWidth || !screenVideo.videoHeight) {
	        throw new Error("No screen frame available.");
	      }
	      const srcW = screenVideo.videoWidth;
	      const srcH = screenVideo.videoHeight;
	      const rois = [];
	      let letterbox = null;
	      for (const box of ROI_BOXES) {
	        const rect = scaledRoiRect(box, srcW, srcH);
	        if (!letterbox && rect.letterbox) {
	          letterbox = rect.letterbox;
	        }
	        if (rect.w < 8 || rect.h < 8) {
	          throw new Error(`ROI too small: ${box.label}`);
	        }
	        const canvas = document.createElement("canvas");
	        canvas.width = rect.w;
	        canvas.height = rect.h;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Canvas context unavailable.");
        }
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(
          screenVideo,
          rect.x,
          rect.y,
          rect.w,
          rect.h,
          0,
          0,
          rect.w,
          rect.h
	        );
	        const blob = await canvasToBlob(canvas, "image/png");
	        rois.push({ label: box.label, rect, blob });
	      }
	      return { source_w: srcW, source_h: srcH, letterbox, rois };
	    }

    function captureVideoFrameBlob() {
      return new Promise(async (resolve, reject) => {
        if (!screenVideo.videoWidth || !screenVideo.videoHeight) {
          reject(new Error("No screen frame available."));
          return;
        }

        const srcW = screenVideo.videoWidth;
        const srcH = screenVideo.videoHeight;
        const resized = fitSize(srcW, srcH, CAPTURE_MAX_LONG_EDGE);

        const canvas = document.createElement("canvas");
        canvas.width = resized.width;
        canvas.height = resized.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Canvas context unavailable."));
          return;
        }
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);

        try {
          let quality = CAPTURE_INITIAL_JPEG_QUALITY;
          let blob = await canvasToBlob(canvas, "image/jpeg", quality);
          while (blob.size > CAPTURE_TARGET_BYTES && quality > CAPTURE_MIN_JPEG_QUALITY) {
            quality = Math.max(CAPTURE_MIN_JPEG_QUALITY, quality - 0.08);
            blob = await canvasToBlob(canvas, "image/jpeg", quality);
            if (quality <= CAPTURE_MIN_JPEG_QUALITY) break;
          }
          resolve({
            blob,
            source_w: srcW,
            source_h: srcH,
            upload_w: canvas.width,
            upload_h: canvas.height,
            jpeg_quality: quality,
          });
        } catch (err) {
          reject(err);
        }
      });
    }

	    async function analyzeCapture() {
	      if (!state.stream) {
	        return;
	      }
		      analyzeBtn.disabled = true;
		      state.successProb = null;
		      state.lastError = null;

		      try {
	        const tCapture0 = performance.now();
	        const formData = new FormData();
	        let captureMode = CAPTURE_PIPELINE;
	        let roiSchemaVersion = ROI_SCHEMA_VERSION;
	        let capture = null;
	        let blob = null;
	        let uploadBytes = 0;
	        let roiLabels = [];
	        let roiCount = 0;
	        let roiRects = [];
	        try {
	          capture = await captureMultiCropPayload();
	          const ts = Date.now();
	          for (const roi of capture.rois) {
	            formData.append(`roi_${roi.label}`, roi.blob, `${roi.label}_${ts}.png`);
	            uploadBytes += roi.blob?.size || 0;
	            roiLabels.push(roi.label);
	            roiRects.push({
	              label: roi.label,
	              w: roi.rect.w,
	              h: roi.rect.h,
	              bytes: roi.blob?.size || 0,
	            });
	          }
	          roiCount = capture.rois.length;
	        } catch (_multiCropErr) {
	          captureMode = FALLBACK_CAPTURE_PIPELINE;
	          roiSchemaVersion = FALLBACK_ROI_SCHEMA_VERSION;
	          capture = await captureVideoFrameBlob();
	          blob = capture.blob;
	          const fileName = `capture_${Date.now()}.jpg`;
	          formData.append("image", blob, fileName);
	          uploadBytes = blob?.size || 0;
	        }
	        const tCapture1 = performance.now();
	        formData.append("willpower", String(state.current.willpower));
        formData.append("points", String(state.current.points));
        formData.append("effect1_level", String(state.current.effect1_level));
        formData.append("effect2_level", String(state.current.effect2_level));
		        formData.append("target_willpower", String(state.target.willpower));
		        formData.append("target_points", String(state.target.points));
	        formData.append("target_effect1_level", String(state.target.effect1_level));
	        formData.append("target_effect2_level", String(state.target.effect2_level));
            formData.append("role", String(state.uiState?.role || "dealer"));
            formData.append("gem_type", String(state.uiState?.gem_type || "stable"));
            formData.append("roi_schema_version", roiSchemaVersion);
		        formData.append(
		          "client_debug",
		          JSON.stringify({
		            capture_ms: Math.round((tCapture1 - tCapture0) * 100) / 100,
                capture_pipeline: captureMode,
                roi_schema_version: roiSchemaVersion,
		            video_w: capture.source_w || screenVideo.videoWidth || null,
		            video_h: capture.source_h || screenVideo.videoHeight || null,
		            upload_w: capture.upload_w || null,
		            upload_h: capture.upload_h || null,
		            upload_bytes: uploadBytes || null,
		            jpeg_quality: capture.jpeg_quality || null,
		            letterbox: capture.letterbox || null,
                roi_count: roiCount,
                roi_labels: roiLabels,
                roi_rects: roiRects,
		          })
		        );

		        const res = await fetch("/api/analyze", {
		          method: "POST",
		          body: formData,
	        });
	        const body1 = await res.json().catch(() => ({}));
	        if (!res.ok || !body1.ok) {
	          const detail =
	            body1?.detail || body1?.error || (Object.keys(body1 || {}).length ? JSON.stringify(body1) : "");
	          const suffix = detail ? `: ${detail}` : (res.statusText ? `: ${res.statusText}` : "");
	          throw new Error(`분석 실패 (HTTP ${res.status})${suffix}`);
	        }

	        let body = body1;
	        let didRetry = false;
	        const countText1 = body1?.ocr_result?.count;
	        const hasCount1 = typeof countText1 === "string" && countText1.includes("/");
	        if (captureMode === CAPTURE_PIPELINE && !hasCount1) {
	          didRetry = true;
	          const tRetry0 = performance.now();
	          const retryForm = new FormData();
	          const retryCapture = await captureVideoFrameBlob();
	          const retryBlob = retryCapture.blob;
	          const retryFileName = `capture_retry_${Date.now()}.jpg`;
	          retryForm.append("image", retryBlob, retryFileName);
	          const tRetry1 = performance.now();
	          retryForm.append("willpower", String(state.current.willpower));
	          retryForm.append("points", String(state.current.points));
	          retryForm.append("effect1_level", String(state.current.effect1_level));
	          retryForm.append("effect2_level", String(state.current.effect2_level));
	          retryForm.append("target_willpower", String(state.target.willpower));
	          retryForm.append("target_points", String(state.target.points));
	          retryForm.append("target_effect1_level", String(state.target.effect1_level));
	          retryForm.append("target_effect2_level", String(state.target.effect2_level));
	          retryForm.append("role", String(state.uiState?.role || "dealer"));
	          retryForm.append("gem_type", String(state.uiState?.gem_type || "stable"));
	          retryForm.append("roi_schema_version", FALLBACK_ROI_SCHEMA_VERSION);
	          retryForm.append(
	            "client_debug",
	            JSON.stringify({
	              capture_ms: Math.round((tRetry1 - tRetry0) * 100) / 100,
	              capture_pipeline: FALLBACK_CAPTURE_PIPELINE,
	              roi_schema_version: FALLBACK_ROI_SCHEMA_VERSION,
	              video_w: retryCapture.source_w || screenVideo.videoWidth || null,
	              video_h: retryCapture.source_h || screenVideo.videoHeight || null,
	              upload_w: retryCapture.upload_w || null,
	              upload_h: retryCapture.upload_h || null,
	              upload_bytes: retryBlob?.size || null,
	              jpeg_quality: retryCapture.jpeg_quality || null,
	              auto_retry: true,
	              retry_reason: "missing_count",
	              retry_of: body1?.record?.id || null,
	              first_capture_pipeline: captureMode,
	              first_roi_schema_version: roiSchemaVersion,
	              first_letterbox: capture?.letterbox || null,
	            })
	          );

	          const res2 = await fetch("/api/analyze", {
	            method: "POST",
	            body: retryForm,
	          });
	          const body2 = await res2.json().catch(() => ({}));
	          if (!res2.ok || !body2.ok) {
	            const detail =
	              body2?.detail || body2?.error || (Object.keys(body2 || {}).length ? JSON.stringify(body2) : "");
	            const suffix = detail ? `: ${detail}` : (res2.statusText ? `: ${res2.statusText}` : "");
	            throw new Error(`분석 재시도 실패 (HTTP ${res2.status})${suffix}`);
	          }
	          body = body2;
	        }

	        state.lastResponse = body;
	        state.successProb = body.goal_success?.success_prob ?? null;
	        const gs = body.goal_success ?? null;
	        if (!gs) {
	          state.lastError = "서버 응답에 성공 확률(goal_success)이 없습니다. 서버를 재시작/업데이트해주세요.";
	        } else if (gs.success_prob == null) {
	          const reason = gs.reason ? String(gs.reason) : "unknown";
	          const errText = gs.error ? `: ${String(gs.error)}` : "";
	          state.lastError = `성공 확률 계산 실패 (${reason}${errText})`;
	        }
		        state.uiState = {
		          rerolls: asInt(body.ui_state?.rerolls, 0),
		          attempts_left: asInt(body.ui_state?.attempts_left, 0),
		          cost_state: asInt(body.ui_state?.cost_state, 0),
	          options: Array.isArray(body.ui_state?.options) ? body.ui_state.options : [],
            role: String(body.ui_state?.role || state.uiState?.role || "dealer"),
            gem_type: String(body.ui_state?.gem_type || state.uiState?.gem_type || "stable"),
	        };
	        state.ocrCount = body.ocr_result?.count || null;

	        const finalCountText = body?.ocr_result?.count;
	        const hasFinalCount = typeof finalCountText === "string" && finalCountText.includes("/");
	        if (!hasFinalCount && !state.lastError) {
	          const hint = didRetry
	            ? "전체 화면으로 재시도했지만 가공 횟수(count) 인식에 실패했습니다."
	            : "가공 횟수(count) 인식에 실패했습니다.";
	          state.lastError = `${hint} (21:9 화면공유/해상도/UI 스케일을 확인해주세요)`;
	        }
	      } catch (err) {
	        let msg = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
	        if (msg.includes("No screen frame available")) {
	          msg = "공유 화면 프레임이 없습니다. 화면 공유를 다시 시작해주세요.";
	        } else if (msg.includes("Failed to capture frame blob")) {
	          msg = "캡처 프레임 생성에 실패했습니다. 화면 공유를 다시 시작해주세요.";
	        } else if (msg.includes("Failed to fetch")) {
	          msg = "서버 연결에 실패했습니다. 서버가 실행 중인지 확인해주세요.";
	        }
	        state.lastError = msg;
	        console.error(err);
	      } finally {
	        analyzeBtn.disabled = false;
	        renderAll();
	      }
	    }

	    function applyOption(index) {
      const options = Array.isArray(state.uiState.options) ? state.uiState.options : [];
      const opt = options[index];
      if (!opt) return;

      const category = String(opt.category || "").toLowerCase();
      const value = asInt(opt.value, 0);

      if (category === "willpower") {
        state.current.willpower = clampStat(state.current.willpower + value);
      } else if (category === "points") {
        state.current.points = clampStat(state.current.points + value);
      } else if (category === "effect1") {
        if (value !== 0) {
          state.current.effect1_level = clampStat(state.current.effect1_level + value);
        }
      } else if (category === "effect2") {
        if (value !== 0) {
          state.current.effect2_level = clampStat(state.current.effect2_level + value);
        }
      } else if (category === "special") {
        if (isRerollOption(opt)) {
          const gain = Math.max(1, Math.min(2, Math.abs(value || 1)));
          state.uiState.rerolls = Math.max(0, asInt(state.uiState.rerolls, 0) + gain);
        } else if (isCostOption(opt)) {
          const delta = value >= 0 ? 1 : -1;
          state.uiState.cost_state = Math.max(-1, Math.min(1, asInt(state.uiState.cost_state, 0) + delta));
        }
      }

      if (asInt(state.uiState.attempts_left, 0) > 0) {
        state.uiState.attempts_left -= 1;
      }

      state.uiState.options = [];
      state.ocrCount = `${Math.max(0, asInt(state.uiState.attempts_left, 0))}`;
	      renderAll();
	    }

      function bindRoleGemControls() {
        if (roleSelect) {
          roleSelect.addEventListener("change", () => {
            const v = String(roleSelect.value || "").toLowerCase();
            state.uiState.role = v === "support" ? "support" : "dealer";
            renderAll();
          });
        }
        if (gemTypeSelect) {
          gemTypeSelect.addEventListener("change", () => {
            const v = String(gemTypeSelect.value || "").toLowerCase();
            if (v === "solid" || v === "immutable" || v === "stable") {
              state.uiState.gem_type = v;
            } else {
              state.uiState.gem_type = "stable";
            }
            renderAll();
          });
        }
      }

		    function bindStatControls() {
	      document.querySelectorAll("button[data-op]").forEach((btn) => {
	        btn.addEventListener("click", () => {
	          const key = btn.dataset.key;
	          const op = btn.dataset.op;
	          if (!key || !op) return;
	          const targetObj = op.includes("target") ? state.target : state.current;
	          const fallback = op.includes("target") ? 4 : 1;
	          const current = asInt(targetObj[key], fallback);
	          if (op === "inc-current" || op === "inc-target") {
	            targetObj[key] = clampStat(current + 1);
	          } else if (op === "dec-current" || op === "dec-target") {
	            targetObj[key] = clampStat(current - 1);
	          }
	          renderAll();
	        });
	      });

      document.querySelectorAll("input[data-input='current']").forEach((input) => {
        input.addEventListener("change", () => {
          const key = input.dataset.key;
          if (!key) return;
          state.current[key] = clampStat(input.value);
          renderAll();
        });
      });

      document.querySelectorAll("input[data-input='target']").forEach((input) => {
        input.addEventListener("change", () => {
          const key = input.dataset.key;
          if (!key) return;
          state.target[key] = clampStat(input.value);
          renderAll();
        });
      });
    }

		    shareStartBtn.addEventListener("click", startShare);
		    shareStopBtn.addEventListener("click", stopShare);
			    analyzeBtn.addEventListener("click", analyzeCapture);
			    resetBtn.addEventListener("click", resetGemState);
	    if (bugReportSendBtn) {
	      bugReportSendBtn.addEventListener("click", submitBugReport);
	    }

	        bindRoleGemControls();
			    bindStatControls();
		    setSharingUI(false);
		    renderAll();
  </script>
</body>
</html>
