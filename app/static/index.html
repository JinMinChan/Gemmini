<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>젬미나이</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-1: #0a1422;
      --bg-2: #1d2f44;
      --card: #0f1f2f;
      --line: #2f516f;
      --line-soft: #23415b;
      --accent-gold: #ffd166;
      --accent-cyan: #6ee7f7;
      --accent-green: #89f59d;
      --accent-red: #ff8b8b;
      --text-main: #eef5ff;
      --text-sub: #b9c9dc;

      /* category colors (from gem_prog.py) */
      --stat-will: #ff5a3c;
      --stat-point: #f5c542;
      --stat-eff1: #6bff4a;
      --stat-eff2: #4fd6ff;
      --stat-special: #aaaaaa;
    }

    body {
      font-family: "Exo 2", sans-serif;
      color: var(--text-main);
      background:
        radial-gradient(circle at 8% 12%, rgba(110, 231, 247, 0.16), transparent 30%),
        radial-gradient(circle at 92% 82%, rgba(255, 209, 102, 0.12), transparent 34%),
        linear-gradient(130deg, var(--bg-1), var(--bg-2));
      min-height: 100vh;
    }

    .panel {
      background: linear-gradient(170deg, rgba(15, 31, 47, 0.93), rgba(10, 21, 35, 0.9));
      border: 1px solid var(--line);
      box-shadow: 0 12px 36px rgba(1, 9, 17, 0.36);
      border-radius: 1rem;
    }

    .halo {
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: inset 0 0 40px rgba(110, 231, 247, 0.08);
      border-radius: 1rem;
    }

    .glow-btn {
      transition: transform 140ms ease, box-shadow 140ms ease, opacity 140ms ease;
    }

    .glow-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 8px 22px rgba(110, 231, 247, 0.26);
    }

    .glow-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

	    .diamond-shell {
	      --dia-border: var(--line-soft);
	      --dia-accent: var(--accent-cyan);
	      --dia-tint: rgba(110, 231, 247, 0.12);
		      width: clamp(7.25rem, 15vw, 9.5rem);
		      height: clamp(7.25rem, 15vw, 9.5rem);
		      transform: rotate(45deg);
		      border: 1px solid var(--dia-border);
		      border-radius: 1.25rem;
      background:
        radial-gradient(circle at 18% 18%, var(--dia-tint), transparent 62%),
        linear-gradient(140deg, rgba(32, 53, 73, 0.84), rgba(12, 26, 40, 0.9));
      box-shadow: inset 0 0 34px var(--dia-tint);
	      overflow: hidden;
	    }

		    .diamond-stage {
		      width: clamp(19rem, 42vw, 26rem);
		      height: clamp(19rem, 42vw, 26rem);
		    }

    .diamond-shell .stat-name {
      color: var(--dia-accent);
    }

    .diamond-shell .mini-control {
      border-color: var(--dia-border);
    }

    .diamond-shell .stat-input {
      border-color: var(--dia-border);
    }

    .diamond-will {
      --dia-border: rgba(255, 90, 60, 0.55);
      --dia-accent: var(--stat-will);
      --dia-tint: rgba(255, 90, 60, 0.14);
    }

    .diamond-point {
      --dia-border: rgba(245, 197, 66, 0.55);
      --dia-accent: var(--stat-point);
      --dia-tint: rgba(245, 197, 66, 0.12);
    }

    .diamond-eff1 {
      --dia-border: rgba(107, 255, 74, 0.55);
      --dia-accent: var(--stat-eff1);
      --dia-tint: rgba(107, 255, 74, 0.12);
    }

    .diamond-eff2 {
      --dia-border: rgba(79, 214, 255, 0.55);
      --dia-accent: var(--stat-eff2);
      --dia-tint: rgba(79, 214, 255, 0.12);
    }

	    .diamond-inner {
	      width: 100%;
	      height: 100%;
	      transform: rotate(-45deg);
	      display: flex;
	      flex-direction: column;
	      align-items: center;
	      justify-content: center;
	      gap: 0.3rem;
	      padding: 0.3rem clamp(0.5rem, 1.8vw, 0.8rem);
	    }

	    .mini-control {
	      width: clamp(1.1rem, 3.8vw, 1.45rem);
	      height: clamp(1.1rem, 3.8vw, 1.45rem);
	      border-radius: 0.4rem;
	      border: 1px solid #446b8c;
	      color: #d8ecff;
	      background: rgba(36, 60, 80, 0.9);
      font-weight: 700;
      line-height: 1;
    }

    .stat-input {
      width: clamp(1.85rem, 4.6vw, 2.3rem);
      border-radius: 0.45rem;
      border: 1px solid #3f5f7d;
      background: rgba(11, 24, 37, 0.9);
      color: #dff2ff;
      text-align: center;
      font-weight: 700;
    }

    .selector-card {
      border: 1px solid rgba(101, 168, 218, 0.45);
      border-radius: 0.65rem;
      background: linear-gradient(160deg, rgba(20, 44, 67, 0.82), rgba(12, 26, 43, 0.86));
      padding: 0.55rem 0.65rem;
    }

    .selector-select {
      width: 100%;
      border-radius: 0.5rem;
      border: 1px solid #3f5f7d;
      background: rgba(11, 24, 37, 0.95);
      color: #dff2ff;
      font-weight: 600;
      font-size: 0.82rem;
      padding: 0.35rem 0.45rem;
      outline: none;
    }

    /* Hide number input spinners (we use +/- buttons instead). */
    input[type="number"]::-webkit-outer-spin-button,
    input[type="number"]::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    .option-card {
      --opt-border: #2b4c68;
      --opt-hover: #64d8ee;
      --opt-glow: rgba(110, 231, 247, 0.2);
      --opt-tint: rgba(110, 231, 247, 0.12);
      border: 1px solid var(--opt-border);
      background:
        radial-gradient(circle at 18% 18%, var(--opt-tint), transparent 62%),
        linear-gradient(160deg, rgba(20, 44, 67, 0.9), rgba(12, 26, 43, 0.92));
      color: #dcefff;
      border-radius: 0.9rem;
      min-height: 4.35rem;
      transition: transform 140ms ease, border-color 140ms ease, box-shadow 140ms ease;
    }

    .option-card:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: var(--opt-hover);
      box-shadow: 0 7px 18px var(--opt-glow);
    }

    .option-card:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .opt-will {
      --opt-border: rgba(255, 90, 60, 0.45);
      --opt-hover: var(--stat-will);
      --opt-glow: rgba(255, 90, 60, 0.22);
      --opt-tint: rgba(255, 90, 60, 0.16);
    }

    .opt-point {
      --opt-border: rgba(245, 197, 66, 0.45);
      --opt-hover: var(--stat-point);
      --opt-glow: rgba(245, 197, 66, 0.22);
      --opt-tint: rgba(245, 197, 66, 0.14);
    }

    .opt-eff1 {
      --opt-border: rgba(107, 255, 74, 0.45);
      --opt-hover: var(--stat-eff1);
      --opt-glow: rgba(107, 255, 74, 0.22);
      --opt-tint: rgba(107, 255, 74, 0.14);
    }

    .opt-eff2 {
      --opt-border: rgba(79, 214, 255, 0.45);
      --opt-hover: var(--stat-eff2);
      --opt-glow: rgba(79, 214, 255, 0.22);
      --opt-tint: rgba(79, 214, 255, 0.14);
    }

    .opt-special {
      --opt-border: rgba(170, 170, 170, 0.35);
      --opt-hover: var(--stat-special);
      --opt-glow: rgba(170, 170, 170, 0.2);
      --opt-tint: rgba(170, 170, 170, 0.12);
    }
  </style>
</head>
<body>
  <main class="mx-auto max-w-7xl px-4 py-6 sm:px-6 lg:px-8">
    <header class="panel p-4 sm:p-5">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <div>
          <h1 class="text-2xl font-extrabold tracking-tight text-sky-100">젬미나이</h1>
          <p class="mt-1 text-sm text-slate-300">게임 창을 공유한 뒤 <span class="font-semibold text-cyan-300">젬미나이</span>를 누르면 추천 행동이 표시됩니다. 가공 후 옵션을 선택해주세요.</p>
        </div>
        <div class="flex flex-wrap gap-2">
          <button id="shareStartBtn" class="glow-btn rounded-lg border border-cyan-400/50 bg-cyan-400/15 px-4 py-2 text-sm font-semibold text-cyan-100">
            화면 공유 시작
          </button>
          <button id="shareStopBtn" class="glow-btn rounded-lg border border-slate-500/60 bg-slate-500/15 px-4 py-2 text-sm font-semibold text-slate-200" disabled>
            공유 중지
          </button>
        </div>
      </div>
      <div class="mt-3 flex flex-wrap items-center gap-x-6 gap-y-2 text-sm">
        <div>
          서버 상태:
          <span id="serverStatus" class="ml-1 font-semibold text-slate-200">확인 중</span>
        </div>
      </div>
    </header>

    <section class="mt-5 grid gap-4 lg:grid-cols-[1.1fr_1fr]">
      <div class="panel p-4">
        <div class="flex items-center justify-between gap-3">
          <h2 class="text-lg font-bold text-sky-100">공유 화면</h2>
          <div class="flex items-center gap-2">
            <button
              id="roiAdjustBtn"
              class="glow-btn rounded-md border border-slate-500/60 bg-slate-500/10 px-3 py-1.5 text-xs font-semibold text-slate-100"
              disabled
            >
              화면 조정
            </button>
            <div class="relative group">
              <button
                type="button"
                class="glow-btn flex h-7 w-7 items-center justify-center rounded-full border border-slate-500/60 bg-slate-500/10 text-xs font-extrabold text-slate-100"
                aria-label="화면 조정 도움말"
              >
                ?
              </button>
              <div
                class="pointer-events-none absolute right-0 top-full z-10 mt-2 hidden w-max max-w-xs rounded-md border border-slate-700 bg-slate-950/95 px-3 py-2 text-xs text-slate-200 shadow-lg group-hover:block"
              >
                화면 인식할 부분을 조정합니다
              </div>
            </div>
          </div>
        </div>
        <p class="mt-1 text-xs text-slate-300">공유화면 아래 설정에 게임 창을 선택해주세요.</p>
        <div class="halo mt-3 p-3">
          <video id="screenVideo" class="h-[18rem] w-full rounded-xl border border-slate-700/80 bg-slate-950 object-contain sm:h-[22rem]" autoplay muted playsinline></video>
        </div>
        <div class="mt-4 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
          <div class="text-sm font-semibold text-sky-100">버그 제보하기</div>
          <p class="mt-1 text-xs text-slate-300">버그 제보시 버그 수정을 위해 이미지와 AI 결과가 서버에 저장됩니다.</p>
          <textarea
            id="bugReportInput"
            class="mt-2 h-24 w-full rounded-md border border-slate-700 bg-slate-950/85 px-3 py-2 text-sm text-slate-100 outline-none focus:border-cyan-400/70"
            placeholder="예: 리롤 2회인데 3회로 표시됩니다."
          ></textarea>
          <div class="mt-2 flex items-center justify-between gap-2">
            <button
              id="bugReportSendBtn"
              class="glow-btn rounded-lg border border-cyan-400/60 bg-cyan-400/15 px-3 py-2 text-xs font-semibold text-cyan-100"
            >
              보내기
            </button>
            <div id="bugReportStatus" class="hidden text-xs"></div>
          </div>
        </div>

		        <div class="mt-3 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
		          <div class="text-sm font-semibold text-sky-100">공지사항</div>
		          <ul id="noticeList" class="mt-2 space-y-1 text-xs text-slate-300">
		            <li>공지사항을 불러오는 중입니다...</li>
		          </ul>
		        </div>

        <div class="mt-3 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
          <div class="text-sm font-semibold text-sky-100">마음의 편지</div>

          <div
            id="letterList"
            class="mt-2 max-h-56 overflow-auto rounded-md border border-slate-700 bg-slate-950/70 p-2 text-xs text-slate-200"
          >
            <div class="text-slate-400">불러오는 중...</div>
          </div>

          <textarea
            id="letterInput"
            class="mt-2 h-20 w-full rounded-md border border-slate-700 bg-slate-950/85 px-3 py-2 text-sm text-slate-100 outline-none focus:border-cyan-400/70"
            placeholder="예: 젬미나이 때문에 10겁작이 사라졌어요!"
          ></textarea>
          <div class="mt-2 flex items-center justify-between gap-2">
            <button
              id="letterSendBtn"
              class="glow-btn rounded-lg border border-cyan-400/60 bg-cyan-400/15 px-3 py-2 text-xs font-semibold text-cyan-100"
            >
              남기기
            </button>
            <div id="letterStatus" class="hidden text-xs"></div>
          </div>
        </div>
	      </div>

      <div class="panel p-4">
        <div class="flex flex-wrap items-center justify-between gap-3">
          <h2 class="text-lg font-bold text-sky-100">젬 상태</h2>
          <div class="text-sm text-slate-300">
            현재 합계: <span id="currentSum" class="font-bold text-cyan-200">4</span> /
            목표 합계: <span id="targetSum" class="font-bold text-amber-200">16</span>
          </div>
        </div>
        <p class="mt-1 text-xs text-slate-300">실제 게임에서 적용된 옵션을 눌러 현재 스탯에 반영하세요.</p>

        <div class="mt-3 grid gap-2 sm:grid-cols-2">
          <label class="selector-card">
            <div class="text-[11px] font-semibold uppercase tracking-wide text-slate-300">역할</div>
            <select id="roleSelect" class="selector-select mt-1">
              <option value="dealer">딜러</option>
              <option value="support">서폿</option>
            </select>
          </label>
          <label class="selector-card">
            <div class="text-[11px] font-semibold uppercase tracking-wide text-slate-300">젬 종류</div>
            <select id="gemTypeSelect" class="selector-select mt-1">
              <option value="stable">안정/침식</option>
              <option value="solid">견고/왜곡</option>
              <option value="immutable">불변/붕괴</option>
            </select>
          </label>
        </div>

        <div class="halo mt-3 p-3 sm:p-4">
			          <div class="diamond-stage relative mx-auto max-w-full">
		            <div class="absolute left-1/2 top-5 -translate-x-1/2">
	              <div class="diamond-shell diamond-will">
	                <div class="diamond-inner" data-stat="willpower">
                  <div class="stat-name text-xs font-semibold">의지력</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="willpower">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="willpower" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="willpower">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="willpower">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="willpower" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="willpower">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute left-5 top-1/2 -translate-y-1/2">
	              <div class="diamond-shell diamond-eff1">
	                <div class="diamond-inner" data-stat="effect1_level">
                  <div class="stat-name text-xs font-semibold">부옵션1</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="effect1_level">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="effect1_level" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="effect1_level">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="effect1_level">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="effect1_level" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="effect1_level">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute right-5 top-1/2 -translate-y-1/2">
	              <div class="diamond-shell diamond-eff2">
	                <div class="diamond-inner" data-stat="effect2_level">
                  <div class="stat-name text-xs font-semibold">부옵션2</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="effect2_level">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="effect2_level" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="effect2_level">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="effect2_level">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="effect2_level" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="effect2_level">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>

		            <div class="absolute bottom-5 left-1/2 -translate-x-1/2">
              <div class="diamond-shell diamond-point">
                <div class="diamond-inner" data-stat="points">
                  <div class="stat-name text-xs font-semibold">질서/혼돈</div>
                  <div class="flex items-center gap-1">
                    <button class="mini-control" data-op="dec-current" data-key="points">-</button>
                    <input class="stat-input" type="number" min="1" max="5" data-input="current" data-key="points" value="1" />
                    <button class="mini-control" data-op="inc-current" data-key="points">+</button>
	                  </div>
		                  <div class="mt-1 flex items-center gap-1 text-[11px] text-slate-300">
		                    <span class="shrink-0 whitespace-nowrap">목표</span>
		                    <button class="mini-control" data-op="dec-target" data-key="points">-</button>
		                    <input class="stat-input" type="number" min="1" max="5" data-input="target" data-key="points" value="4" />
		                    <button class="mini-control" data-op="inc-target" data-key="points">+</button>
		                  </div>
		                </div>
		              </div>
	            </div>
          </div>
        </div>

	        <div class="mt-4 grid grid-cols-2 gap-2 sm:grid-cols-4">
	          <button id="resetBtn" class="glow-btn rounded-lg border border-rose-400/60 bg-rose-400/15 px-4 py-3 text-sm font-bold text-rose-100">
	            초기화
	          </button>
	          <div class="hidden sm:block"></div>
	          <div class="hidden sm:block"></div>
	          <button id="analyzeBtn" class="glow-btn rounded-lg border border-amber-300/60 bg-amber-300/20 px-4 py-3 text-sm font-bold text-amber-100" disabled>
	            젬미나이
	          </button>
	        </div>

	        <div id="analyzeError" class="mt-2 hidden rounded-lg border border-rose-400/40 bg-rose-400/10 px-3 py-2 text-xs text-rose-100"></div>

	        <div id="optionsGrid" class="mt-2 grid grid-cols-2 gap-2 sm:grid-cols-4"></div>

        <div class="mt-4 rounded-lg border border-slate-700/80 bg-slate-900/70 p-3">
          <div class="text-xs font-semibold uppercase tracking-wide text-slate-400">추천 행동</div>
          <div id="actionCard" class="mt-2 grid grid-cols-1 overflow-hidden rounded-md border border-slate-700 bg-slate-950/85">
            <div class="px-3 py-3 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">추천</div>
              <div id="actionText" class="mt-1 text-lg font-extrabold text-slate-200">-</div>
            </div>
            <div class="border-t border-slate-800/80 px-3 py-3 text-center">
              <div class="text-[11px] uppercase tracking-wide text-slate-400">성공 확률</div>
              <div id="successProbText" class="mt-1 text-lg font-extrabold text-rose-200">-</div>
            </div>
          </div>
	          <div class="mt-3 grid grid-cols-3 gap-2">
	            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
	              <div class="text-[11px] uppercase tracking-wide text-slate-400">리롤</div>
	              <div class="mt-1 flex items-center justify-center gap-2">
	                <button class="mini-control" data-adjust="rerolls" data-delta="-1">-</button>
	                <div id="rerollsText" class="min-w-[2ch] text-lg font-bold text-slate-100">-</div>
	                <button class="mini-control" data-adjust="rerolls" data-delta="1">+</button>
	              </div>
	            </div>
	            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
	              <div class="text-[11px] uppercase tracking-wide text-slate-400">가공횟수</div>
	              <div class="mt-1 flex items-center justify-center gap-2">
	                <button class="mini-control" data-adjust="attempts_left" data-delta="-1">-</button>
	                <div id="countText" class="min-w-[2ch] text-lg font-bold text-slate-100">-</div>
	                <button class="mini-control" data-adjust="attempts_left" data-delta="1">+</button>
	              </div>
	            </div>
	            <div class="rounded-md border border-slate-700 bg-slate-950/85 px-2 py-2 text-center">
	              <div class="text-[11px] uppercase tracking-wide text-slate-400">가공비용</div>
	              <div class="mt-1 flex items-center justify-center gap-2">
	                <button class="mini-control" data-adjust="cost_state" data-delta="-1">-</button>
	                <div id="costText" class="min-w-[5ch] text-lg font-bold text-slate-100">-</div>
	                <button class="mini-control" data-adjust="cost_state" data-delta="1">+</button>
	              </div>
	            </div>
	          </div>
	        </div>
      </div>
    </section>
  </main>

  <div id="roiAdjustModal" class="fixed inset-0 z-50 hidden items-center justify-center bg-black/70 p-4">
    <div class="panel w-full max-w-6xl p-4 sm:p-5">
      <div class="flex flex-wrap items-center justify-between gap-3">
        <div>
          <div class="text-lg font-extrabold tracking-tight text-sky-100">화면 조정</div>
          <div class="mt-1 text-xs text-slate-300">박스를 드래그해서 화면 인식 위치를 맞춘 뒤 적용을 누르세요.</div>
        </div>
        <div class="flex items-center gap-2">
          <button
            id="roiAdjustCancelBtn"
            class="glow-btn rounded-lg border border-slate-500/60 bg-slate-500/10 px-4 py-2 text-sm font-semibold text-slate-100"
          >
            취소
          </button>
          <button
            id="roiAdjustApplyBtn"
            class="glow-btn rounded-lg border border-cyan-400/60 bg-cyan-400/15 px-4 py-2 text-sm font-semibold text-cyan-100"
          >
            적용
          </button>
        </div>
      </div>

      <div class="mt-4 grid gap-3 lg:grid-cols-[1fr_16rem]">
        <div id="roiAdjustPreviewWrap" class="relative h-[68vh] w-full overflow-hidden rounded-xl border border-slate-700/80 bg-slate-950">
          <img id="roiAdjustPreviewImg" class="absolute inset-0 h-full w-full object-contain" alt="ROI 미리보기" />
          <div id="roiAdjustOverlay" class="absolute inset-0">
            <div
              id="roiDragOptions"
              data-drag="options"
              class="group pointer-events-auto absolute touch-none rounded-md border-2 border-rose-400/90 bg-rose-400/5 shadow-[0_0_0_1px_rgba(0,0,0,0.3)] cursor-move"
            >
              <div class="pointer-events-none absolute -top-7 left-0 whitespace-nowrap rounded bg-slate-950/70 px-2 py-0.5 text-[11px] font-extrabold text-rose-200 opacity-0 transition-opacity duration-150 group-hover:opacity-100 group-active:opacity-100">옵션</div>
              <div id="roiOptSep1" class="absolute top-0 h-full w-[2px] bg-rose-400/70"></div>
              <div id="roiOptSep2" class="absolute top-0 h-full w-[2px] bg-rose-400/70"></div>
              <div id="roiOptSep3" class="absolute top-0 h-full w-[2px] bg-rose-400/70"></div>
            </div>

            <div
              id="roiDragReroll"
              data-drag="possible"
              class="group pointer-events-auto absolute touch-none rounded-md border-2 border-cyan-300/90 bg-cyan-300/5 shadow-[0_0_0_1px_rgba(0,0,0,0.3)] cursor-move"
            >
              <div class="pointer-events-none absolute -top-7 left-0 whitespace-nowrap rounded bg-slate-950/70 px-2 py-0.5 text-[11px] font-extrabold text-cyan-200 opacity-0 transition-opacity duration-150 group-hover:opacity-100 group-active:opacity-100">리롤</div>
            </div>

            <div
              id="roiDragCount"
              data-drag="count"
              class="group pointer-events-auto absolute touch-none rounded-md border-2 border-amber-300/90 bg-amber-300/5 shadow-[0_0_0_1px_rgba(0,0,0,0.3)] cursor-move"
            >
              <div class="pointer-events-none absolute -top-7 left-0 whitespace-nowrap rounded bg-slate-950/70 px-2 py-0.5 text-[11px] font-extrabold text-amber-200 opacity-0 transition-opacity duration-150 group-hover:opacity-100 group-active:opacity-100">가공횟수</div>
            </div>

            <div
              id="roiDragCost"
              data-drag="cost"
              class="group pointer-events-auto absolute touch-none rounded-md border-2 border-emerald-300/90 bg-emerald-300/5 shadow-[0_0_0_1px_rgba(0,0,0,0.3)] cursor-move"
            >
              <div class="pointer-events-none absolute -top-7 left-0 whitespace-nowrap rounded bg-slate-950/70 px-2 py-0.5 text-[11px] font-extrabold text-emerald-200 opacity-0 transition-opacity duration-150 group-hover:opacity-100 group-active:opacity-100">골드</div>
            </div>
          </div>
        </div>

        <div class="rounded-lg border border-slate-700/80 bg-slate-900/70 p-3 text-xs text-slate-200">
          <div class="text-sm font-semibold text-sky-100">조정 대상</div>
          <ul class="mt-2 list-disc pl-4 text-slate-300">
            <li>옵션: 4개 옵션 영역을 한 번에 이동합니다.</li>
            <li>리롤: 우측 상단 “n회 가능” 영역입니다.</li>
            <li>가공횟수: 하단 “(n/9)” 영역입니다.</li>
            <li>골드: 우측 하단 비용 숫자 영역입니다.</li>
          </ul>
          <div class="mt-3 text-[11px] text-slate-400">
            팁: 옵션 박스는 내부 선(4등분)으로 실제 옵션 칸과 정렬하세요.
          </div>
          <div class="mt-4 border-t border-slate-700/80 pt-3">
            <div class="text-sm font-semibold text-sky-100">예시 이미지</div>
            <div class="mt-1 text-[11px] text-slate-400">기본 16:9 기준 예시입니다. (클릭하면 크게 볼 수 있어요)</div>
            <div class="mt-2 grid gap-1 text-[11px] text-slate-300">
              <div class="flex items-center gap-2">
                <span class="h-2.5 w-2.5 rounded-sm bg-rose-400"></span>
                <span>옵션</span>
              </div>
              <div class="flex items-center gap-2">
                <span class="h-2.5 w-2.5 rounded-sm bg-cyan-300"></span>
                <span>리롤</span>
              </div>
              <div class="flex items-center gap-2">
                <span class="h-2.5 w-2.5 rounded-sm bg-amber-300"></span>
                <span>가공횟수</span>
              </div>
              <div class="flex items-center gap-2">
                <span class="h-2.5 w-2.5 rounded-sm bg-emerald-300"></span>
                <span>골드</span>
              </div>
            </div>
            <a href="/static/roi_example.jpg" target="_blank" rel="noreferrer">
              <img
                src="/static/roi_example.jpg"
                alt="ROI 예시"
                loading="lazy"
                class="mt-2 w-full rounded-md border border-slate-700/80"
              />
            </a>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
			    const shareStartBtn = document.getElementById("shareStartBtn");
			    const shareStopBtn = document.getElementById("shareStopBtn");
				    const analyzeBtn = document.getElementById("analyzeBtn");
				    const resetBtn = document.getElementById("resetBtn");
				    const screenVideo = document.getElementById("screenVideo");
				    const roiAdjustBtn = document.getElementById("roiAdjustBtn");
				    const roiAdjustModal = document.getElementById("roiAdjustModal");
				    const roiAdjustPreviewWrap = document.getElementById("roiAdjustPreviewWrap");
				    const roiAdjustPreviewImg = document.getElementById("roiAdjustPreviewImg");
				    const roiAdjustOverlay = document.getElementById("roiAdjustOverlay");
				    const roiAdjustCancelBtn = document.getElementById("roiAdjustCancelBtn");
				    const roiAdjustApplyBtn = document.getElementById("roiAdjustApplyBtn");
				    const roiDragOptions = document.getElementById("roiDragOptions");
				    const roiDragReroll = document.getElementById("roiDragReroll");
				    const roiDragCount = document.getElementById("roiDragCount");
				    const roiDragCost = document.getElementById("roiDragCost");
				    const roiOptSep1 = document.getElementById("roiOptSep1");
				    const roiOptSep2 = document.getElementById("roiOptSep2");
				    const roiOptSep3 = document.getElementById("roiOptSep3");
				    const bugReportInput = document.getElementById("bugReportInput");
				    const bugReportSendBtn = document.getElementById("bugReportSendBtn");
				    const bugReportStatus = document.getElementById("bugReportStatus");
				    const noticeList = document.getElementById("noticeList");
					    const analyzeError = document.getElementById("analyzeError");
		          const roleSelect = document.getElementById("roleSelect");
		          const gemTypeSelect = document.getElementById("gemTypeSelect");

    const serverStatus = document.getElementById("serverStatus");
    const actionText = document.getElementById("actionText");
    const successProbText = document.getElementById("successProbText");
    const rerollsText = document.getElementById("rerollsText");
    const countText = document.getElementById("countText");
    const costText = document.getElementById("costText");
    const optionsGrid = document.getElementById("optionsGrid");
    const letterList = document.getElementById("letterList");
    const letterInput = document.getElementById("letterInput");
    const letterSendBtn = document.getElementById("letterSendBtn");
    const letterStatus = document.getElementById("letterStatus");

			    const currentSumEl = document.getElementById("currentSum");
			    const targetSumEl = document.getElementById("targetSum");

	      const DEFAULT_NOTICE_ITEMS = [
	        "2026-02-14: 다양한 해상도를 지원하는 과정에서 화면 인식 버그가 발생하고 있습니다.",
	        "2026-02-14: 리롤/가공횟수/가공비용은 아래 +/- 버튼으로 수동 조정해서 사용 가능합니다.",
	        "2026-02-14: 공유 화면 옆 '화면 조정'에서 인식 영역을 드래그로 조정할 수 있습니다.",
	      ];

	      function renderNoticeItems(items) {
	        if (!noticeList) return;
	        noticeList.innerHTML = "";
	        const list = Array.isArray(items) ? items : [];
	        if (list.length === 0) {
	          const li = document.createElement("li");
	          li.textContent = "공지사항이 없습니다.";
	          noticeList.appendChild(li);
	          return;
	        }
	        for (const raw of list) {
	          const li = document.createElement("li");
	          li.textContent = String(raw || "").trim();
	          noticeList.appendChild(li);
	        }
	      }

	      async function loadNotice() {
	        // Server-side notice so we can update without redeploying the frontend.
	        try {
	          const res = await fetch("/api/notice", { method: "GET", cache: "no-store" });
	          const body = await res.json().catch(() => ({}));
	          if (!res.ok || !body || body.ok !== true) return;
	          const items = Array.isArray(body.items) ? body.items : [];
	          if (items.length) renderNoticeItems(items);
	        } catch (_err) {
	          // Ignore notice failures.
	        }
	      }

      function setServerStatusBadge(ok) {
        if (!serverStatus) return;
        if (ok === true) {
          serverStatus.textContent = "서버 정상";
          serverStatus.className = "ml-1 font-semibold text-emerald-300";
          return;
        }
        if (ok === false) {
          serverStatus.textContent = "서버 점검중";
          serverStatus.className = "ml-1 font-semibold text-amber-300";
          return;
        }
        serverStatus.textContent = "확인 중";
        serverStatus.className = "ml-1 font-semibold text-slate-200";
      }

      async function refreshServerStatus() {
        setServerStatusBadge(null);
        const health = await checkBackendHealthy();
        setServerStatusBadge(Boolean(health.ok));
        return health;
      }

      function setLetterUiStatus(message, tone = "info") {
        if (!letterStatus) return;
        const text = String(message || "").trim();
        if (!text) {
          letterStatus.textContent = "";
          letterStatus.className = "hidden text-xs";
          return;
        }
        let cls = "text-slate-300";
        if (tone === "ok") cls = "text-emerald-300";
        if (tone === "error") cls = "text-rose-300";
        letterStatus.textContent = text;
        letterStatus.className = `text-xs ${cls}`;
      }

      function formatLocalKoreanTime(isoString) {
        const raw = String(isoString || "").trim();
        if (!raw) return "";
        const d = new Date(raw);
        if (Number.isNaN(d.getTime())) return raw.replace("T", " ").slice(0, 19);
        try {
          return d.toLocaleString("ko-KR", { hour12: false });
        } catch (_err) {
          return raw.replace("T", " ").slice(0, 19);
        }
      }

      function renderLetters(items) {
        if (!letterList) return;
        const list = Array.isArray(items) ? items : [];
        if (list.length === 0) {
          letterList.innerHTML = '<div class="text-slate-400">아직 글이 없어요. 첫 글을 남겨주세요!</div>';
          return;
        }

        letterList.innerHTML = list
          .slice(0, 40)
          .map((it) => {
            const msg = escapeHtml(String(it?.message || "").trim() || "(내용 없음)");
            const createdAt = formatLocalKoreanTime(it?.created_at);
            const reply = String(it?.reply || "").trim();
            const replyHtml = reply
              ? `<div class="mt-2 rounded-md border border-slate-800 bg-slate-950/60 px-2 py-2 text-[11px] text-slate-200">
                   <div class="font-semibold text-sky-200">답글</div>
                   <div class="mt-1 whitespace-pre-wrap leading-relaxed text-slate-200">${escapeHtml(reply)}</div>
                 </div>`
              : "";
            return `
              <div class="rounded-md border border-slate-800 bg-slate-950/60 px-2 py-2">
                <div class="flex items-baseline justify-between gap-2">
                  <div class="whitespace-pre-wrap leading-relaxed">${msg}</div>
                  <div class="shrink-0 text-[10px] text-slate-500">${escapeHtml(createdAt)}</div>
                </div>
                ${replyHtml}
              </div>
            `;
          })
          .join("");
      }

      async function loadLetters() {
        if (!letterList) return;
        try {
          const res = await fetch("/api/letters?limit=30", { method: "GET", cache: "no-store" });
          const body = await res.json().catch(() => ({}));
          if (!res.ok || !body || body.ok !== true) return;
          renderLetters(body.items || []);
        } catch (_err) {
          // ignore
        }
      }

      async function submitLetter() {
        if (!letterInput || !letterSendBtn) return;
        const msg = String(letterInput.value || "").trim();
        if (!msg) {
          setLetterUiStatus("내용을 입력해주세요.", "error");
          return;
        }
        if (msg.length > 600) {
          setLetterUiStatus("너무 길어요. (최대 600자)", "error");
          return;
        }

        letterSendBtn.disabled = true;
        setLetterUiStatus("저장 중...", "info");
        try {
          const fd = new FormData();
          fd.append("message", msg);
          if (state.clientId) {
            fd.append("client_id", String(state.clientId));
          }
          const res = await fetch("/api/letters", { method: "POST", body: fd });
          const body = await res.json().catch(() => ({}));
          if (!res.ok || !body || body.ok !== true) {
            const detail = body?.detail || body?.error || res.statusText || "unknown";
            throw new Error(String(detail));
          }
          letterInput.value = "";
          setLetterUiStatus("저장되었습니다. 감사합니다!", "ok");
          await loadLetters();
        } catch (err) {
          const msg2 = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
          setLetterUiStatus(msg2 || "저장 실패", "error");
        } finally {
          letterSendBtn.disabled = false;
        }
      }

	        function makeDefaultUiState(overrides = {}) {
	          return {
	            rerolls: 0,
	            attempts_left: 0,
            cost_state: 0,
            options: [],
            role: "dealer",
            gem_type: "stable",
            ...overrides,
          };
        }

				    const state = {
				      stream: null,
	            clientId: null,
			      current: {
			        willpower: 1,
			        points: 1,
			        effect1_level: 1,
			        effect2_level: 1,
		      },
			      target: {
			        willpower: 4,
			        points: 4,
			        effect1_level: 4,
			        effect2_level: 4,
			      },
			      uiState: makeDefaultUiState(),
	          uiOverride: {
	            rerolls: false,
	            attempts_left: false,
	            cost_state: false,
	          },
            roiOverrides: null,
			      ocrCount: null,
				      lastResponse: null,
					      successProb: null,
					      lastError: null,
					    };

          const CLIENT_ID_STORAGE_KEY = "gemmini_client_id";

          function getOrCreateClientId() {
            try {
              const existing = String(window.localStorage.getItem(CLIENT_ID_STORAGE_KEY) || "").trim();
              if (existing && /^[0-9A-Za-z._-]{6,80}$/.test(existing)) {
                return existing;
              }
              const raw =
                (globalThis.crypto && typeof globalThis.crypto.randomUUID === "function"
                  ? globalThis.crypto.randomUUID()
                  : `${Date.now()}_${Math.random().toString(16).slice(2)}`) || "";
              const sanitized = raw.replace(/[^0-9A-Za-z._-]+/g, "_").replace(/^[_\\.]+|[_\\.]+$/g, "").slice(0, 64);
              const finalId = sanitized || `c_${Math.random().toString(16).slice(2, 10)}`;
              window.localStorage.setItem(CLIENT_ID_STORAGE_KEY, finalId);
              return finalId;
            } catch (_err) {
              return null;
            }
          }

          state.clientId = getOrCreateClientId();

			    function resetGemState() {
			      state.current = {
			        willpower: 1,
			        points: 1,
			        effect1_level: 1,
			        effect2_level: 1,
			      };
			      state.uiState = makeDefaultUiState({
	            role: state.uiState?.role || "dealer",
	            gem_type: state.uiState?.gem_type || "stable",
	          });
	          state.uiOverride = {
	            rerolls: false,
	            attempts_left: false,
	            cost_state: false,
	          };
			      state.ocrCount = null;
				      state.lastResponse = null;
				      state.successProb = null;
			      state.lastError = null;
			      renderAll();
			    }

	    function clampStat(v) {
	      const n = Number(v);
	      if (!Number.isFinite(n)) return 1;
	      return Math.max(1, Math.min(5, Math.round(n)));
	    }

    function asInt(v, fallback = 0) {
      const n = Number(v);
      return Number.isFinite(n) ? Math.trunc(n) : fallback;
    }

	    function costFromState(costState) {
	      if (costState <= -1) return 0;
	      if (costState === 0) return 900;
	      if (costState >= 1) return 1800;
	      return 900;
	    }

	    function clampIntRange(v, lo, hi) {
	      const n = asInt(v, lo);
	      return Math.max(lo, Math.min(hi, n));
	    }

	    function adjustSummaryValue(field, delta) {
	      if (!state.uiState || !state.uiOverride) return;
	      const d = asInt(delta, 0);
	      if (!d) return;

	      if (field === "rerolls") {
	        const next = clampIntRange(asInt(state.uiState.rerolls, 0) + d, 0, 5);
	        state.uiState.rerolls = next;
	        state.uiOverride.rerolls = true;
	      } else if (field === "attempts_left") {
	        const next = clampIntRange(asInt(state.uiState.attempts_left, 0) + d, 0, 9);
	        state.uiState.attempts_left = next;
	        state.uiOverride.attempts_left = true;
	        // Prefer the manual integer display over OCR ratio text once user edits.
	        state.ocrCount = null;
	      } else if (field === "cost_state") {
	        const next = clampIntRange(asInt(state.uiState.cost_state, 0) + d, -1, 1);
	        state.uiState.cost_state = next;
	        state.uiOverride.cost_state = true;
	      } else {
	        return;
	      }

	      renderAll();
	    }

	    function bindSummaryAdjustControls() {
	      document.querySelectorAll("button[data-adjust]").forEach((btn) => {
	        if (btn.dataset.bound === "1") return;
	        btn.dataset.bound = "1";
	        btn.addEventListener("click", () => {
	          const field = String(btn.dataset.adjust || "");
	          const delta = asInt(btn.dataset.delta, 0);
	          adjustSummaryValue(field, delta);
	        });
	      });
	    }

	    function actionKo(actionName) {
	      if (!actionName) return "-";
	      const map = {
	        process: "가공",
        reroll: "리롤",
        stop: "가공 중단",
      };
      return map[actionName] || actionName;
    }

    function textOfOption(opt) {
      if (!opt) return "옵션 없음";
      return String(opt.text || opt.formatted || opt.option || opt.raw_option || "옵션 없음");
    }

    function escapeHtml(text) {
      return String(text)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function optionBlob(opt) {
      return [
        opt?.text || "",
        opt?.formatted || "",
        opt?.raw_option || "",
        opt?.option || "",
      ].join(" ").toLowerCase();
    }

    function isRerollOption(opt) {
      const blob = optionBlob(opt);
      return blob.includes("reroll") || blob.includes("다른 항목") || blob.includes("항목 보기");
    }

    function isCostOption(opt) {
      const blob = optionBlob(opt);
      return blob.includes("cost") || blob.includes("비용");
    }

    function renderStatInputs() {
      document.querySelectorAll("input[data-input='current']").forEach((el) => {
        const key = el.dataset.key;
        el.value = String(state.current[key]);
      });
      document.querySelectorAll("input[data-input='target']").forEach((el) => {
        const key = el.dataset.key;
        el.value = String(state.target[key]);
      });
    }

	    function renderSums() {
	      const currentSum = Object.values(state.current).reduce((acc, v) => acc + asInt(v, 1), 0);
	      const targetSum = Object.values(state.target).reduce((acc, v) => acc + asInt(v, 4), 0);
	      currentSumEl.textContent = String(currentSum);
	      targetSumEl.textContent = String(targetSum);
	    }

      function renderRoleGemSelectors() {
        if (roleSelect) {
          roleSelect.value = String(state.uiState?.role || "dealer");
        }
        if (gemTypeSelect) {
          gemTypeSelect.value = String(state.uiState?.gem_type || "stable");
        }
      }

    function renderOptions() {
      const options = Array.isArray(state.uiState.options) ? state.uiState.options : [];
      const normalized = options.slice(0, 4);
      while (normalized.length < 4) {
        normalized.push(null);
      }

      optionsGrid.innerHTML = normalized.map((opt, idx) => {
        const label = escapeHtml(textOfOption(opt));
        const styleClass = optionStyleClass(opt);
        return `
          <button class="option-card ${styleClass} p-3 text-left text-sm font-semibold" ${opt ? "" : "disabled"} data-option-idx="${idx}">
            <div class="text-xs uppercase tracking-wide text-slate-400">옵션 ${idx + 1}</div>
            <div class="mt-1 leading-snug">${label}</div>
          </button>
        `;
      }).join("");

      optionsGrid.querySelectorAll("[data-option-idx]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const idx = asInt(btn.dataset.optionIdx, -1);
          if (idx < 0) return;
          applyOption(idx);
        });
      });
    }

	    function renderSummaryPanels() {
	      rerollsText.textContent = String(asInt(state.uiState.rerolls, 0));
	      countText.textContent = String(asInt(state.uiState.attempts_left, 0));
	      costText.textContent = `${costFromState(asInt(state.uiState.cost_state, 0))}G`;
	    }

    function optionStyleClass(opt) {
      const category = String(opt?.category || "").toLowerCase();
      if (category === "willpower") return "opt-will";
      if (category === "points") return "opt-point";
      if (category === "effect1" || category === "effect1_level") return "opt-eff1";
      if (category === "effect2" || category === "effect2_level") return "opt-eff2";
      if (category === "special") return "opt-special";
      return "opt-special";
    }

    function renderAction(rl) {
      if (!rl || !rl.action_name) {
        actionText.textContent = "-";
        actionText.className = "mt-1 text-lg font-extrabold text-slate-200";
        return;
      }

      const action = String(rl.action_name);
      const actionNameKo = actionKo(action);
      actionText.textContent = actionNameKo;

      if (action === "process") {
        actionText.className = "mt-1 text-lg font-extrabold text-emerald-300";
      } else if (action === "reroll") {
        actionText.className = "mt-1 text-lg font-extrabold text-cyan-300";
      } else {
        actionText.className = "mt-1 text-lg font-extrabold text-amber-300";
      }
    }

	    function renderSuccessProb() {
	      if (state.successProb == null) {
	        successProbText.textContent = "-";
	        return;
	      }

	      const p = Number(state.successProb);
	      if (!Number.isFinite(p)) {
	        successProbText.textContent = "-";
	        return;
	      }

	      const pct = Math.max(0, Math.min(1, p)) * 100;
	      if (pct > 0 && pct < 0.1) {
	        successProbText.textContent = "<0.1%";
	        return;
	      }
	      if (pct < 1) {
	        successProbText.textContent = `${pct.toFixed(2)}%`;
	        return;
	      }
	      successProbText.textContent = `${pct.toFixed(1)}%`;
	    }

		    function renderAll() {
		      renderStatInputs();
		      renderSums();
          renderRoleGemSelectors();
		      renderSummaryPanels();
		      renderOptions();
		      renderAction(state.lastResponse?.rl || null);
	      renderSuccessProb();
	      renderError();
	    }

		    function renderError() {
		      if (!analyzeError) return;
		      const msg = state.lastError ? String(state.lastError) : "";
		      if (!msg) {
		        analyzeError.textContent = "";
	        analyzeError.classList.add("hidden");
	        return;
	      }
		      analyzeError.textContent = msg;
		      analyzeError.classList.remove("hidden");
		    }

	    function setBugReportStatus(message, tone = "info") {
	      if (!bugReportStatus) return;
	      const text = String(message || "").trim();
	      if (!text) {
	        bugReportStatus.textContent = "";
	        bugReportStatus.className = "hidden text-xs";
	        return;
	      }
	      let cls = "text-slate-300";
	      if (tone === "ok") cls = "text-emerald-300";
	      if (tone === "error") cls = "text-rose-300";
	      bugReportStatus.textContent = text;
	      bugReportStatus.className = `text-xs ${cls}`;
	    }

	    async function submitBugReport() {
	      if (!bugReportInput || !bugReportSendBtn) return;
	      const message = String(bugReportInput.value || "").trim();
	      if (!message) {
	        setBugReportStatus("내용을 입력해주세요.", "error");
	        return;
	      }

	      bugReportSendBtn.disabled = true;
	      setBugReportStatus("전송 중...", "info");
		      try {
		        const fd = new FormData();
		        fd.append("message", message);
            if (state.clientId) {
              fd.append("client_id", String(state.clientId));
            }
		        const recordId = state.lastResponse?.record?.id;
		        if (recordId) {
		          fd.append("record_id", String(recordId));
		        }
	        const res = await fetch("/api/report", {
	          method: "POST",
	          body: fd,
	        });
	        const body = await res.json().catch(() => ({}));
	        if (!res.ok || !body.ok) {
	          const detail = body?.detail || body?.error || res.statusText || "unknown";
	          throw new Error(`제보 저장 실패: ${detail}`);
	        }
	        bugReportInput.value = "";
	        setBugReportStatus("제보가 저장되었습니다. 감사합니다!", "ok");
	      } catch (err) {
	        const msg = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
	        setBugReportStatus(msg || "제보 전송 실패", "error");
	      } finally {
	        bugReportSendBtn.disabled = false;
	      }
	    }

	    function setSharingUI(isSharing) {
	      shareStartBtn.disabled = isSharing;
      shareStopBtn.disabled = !isSharing;
      analyzeBtn.disabled = !isSharing;
      if (roiAdjustBtn) roiAdjustBtn.disabled = !isSharing;
    }

    async function checkBackendHealthy() {
      try {
        const res = await fetch("/api/health", { cache: "no-store" });
        const body = await res.json().catch(() => ({}));
        const ok = Boolean(res.ok && body && body.ok && (body.backend_ok === undefined || body.backend_ok));
        if (ok) return { ok: true };
        const detail = body?.detail || body?.error || res.statusText || "backend unavailable";
        return { ok: false, detail: String(detail) };
      } catch (err) {
        const msg = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
        return { ok: false, detail: msg || "backend unreachable" };
      }
    }

    async function startShare() {
      if (!navigator.mediaDevices?.getDisplayMedia) {
        alert("이 브라우저는 화면 공유 API를 지원하지 않습니다.");
        return;
      }

      const health = await refreshServerStatus();
      if (!health.ok) {
        alert("서버 점검중입니다. 기다려주셔서 감사합니다.");
        return;
      }

      try {
        const stream = await navigator.mediaDevices.getDisplayMedia({
          video: { frameRate: 15 },
          audio: false,
        });
        state.stream = stream;
        screenVideo.srcObject = stream;
        screenVideo.play().catch(() => {});

        const track = stream.getVideoTracks()[0];
        if (track) {
          track.addEventListener("ended", () => {
            stopShare();
          });
        }

        setSharingUI(true);
      } catch (err) {
        setSharingUI(false);
      }
    }

    function stopShare() {
      if (state.stream) {
        state.stream.getTracks().forEach((t) => t.stop());
      }
      state.stream = null;
      screenVideo.srcObject = null;
      setSharingUI(false);
    }

    const ROI_SCHEMA_VERSION = "screen_v2_multicrop";
    const CAPTURE_PIPELINE = "multi_crop_png";
    const FALLBACK_ROI_SCHEMA_VERSION = "screen_v1";
    const FALLBACK_CAPTURE_PIPELINE = "fullframe_resized_jpeg";
    const ROI_BASE_WIDTH = 2560;
    const ROI_BASE_HEIGHT = 1440;
    const ROI_BOXES = [
      { label: "option1", x: 1043.72, y: 793.61, w: 150.71, h: 112.23 },
      { label: "option2", x: 1197.63, y: 795.22, w: 147.50, h: 105.81 },
      { label: "option3", x: 1360.36, y: 796.02, w: 158.72, h: 113.83 },
      { label: "option4", x: 1512.67, y: 795.22, w: 152.31, h: 109.02 },
      { label: "possible", x: 1669.79, y: 794.41, w: 126.66, h: 59.32 },
      // NOTE: cost/count boxes are slightly enlarged to avoid clipping digits
      // under different UI scales (e.g. "1,800" losing the leading '1').
      { label: "cost", x: 1579.21, y: 887.40, w: 150.00, h: 70.00 },
      { label: "count", x: 1476.60, y: 1022.08, w: 120.00, h: 80.00 },
    ];
    const ROI_OVERRIDE_STORAGE_KEY = "gemmini_roi_overrides_screen_v2";
    const ROI_ADJUST_LABELS = ["option1", "option2", "option3", "option4", "possible", "cost", "count"];

    function loadRoiOverridesFromStorage() {
      try {
        const raw = String(window.localStorage.getItem(ROI_OVERRIDE_STORAGE_KEY) || "").trim();
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return null;
        const out = {};
        for (const label of ROI_ADJUST_LABELS) {
          const v = parsed[label];
          if (!v || typeof v !== "object") continue;
          const x = Number(v.x);
          const y = Number(v.y);
          if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
          out[label] = {
            x: Math.max(0, Math.min(ROI_BASE_WIDTH, x)),
            y: Math.max(0, Math.min(ROI_BASE_HEIGHT, y)),
          };
        }
        return Object.keys(out).length ? out : null;
      } catch (_err) {
        return null;
      }
    }

    function saveRoiOverridesToStorage(overrides) {
      try {
        if (!overrides || typeof overrides !== "object") {
          window.localStorage.removeItem(ROI_OVERRIDE_STORAGE_KEY);
          return;
        }
        window.localStorage.setItem(ROI_OVERRIDE_STORAGE_KEY, JSON.stringify(overrides));
      } catch (_err) {
        // ignore storage failures
      }
    }

    function applyRoiOverrides(box, overrides) {
      const ov = overrides && typeof overrides === "object" ? overrides[box.label] : null;
      if (!ov) return box;
      const x = Number(ov.x);
      const y = Number(ov.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return box;
      return { ...box, x, y };
    }

    // Load persisted ROI adjustments after the schema constants exist.
    if (state && state.roiOverrides == null) {
      state.roiOverrides = loadRoiOverridesFromStorage();
    }
    const CAPTURE_MAX_LONG_EDGE = 1920;
    const CAPTURE_TARGET_BYTES = 1_600_000; // ~1.6MB
    const CAPTURE_INITIAL_JPEG_QUALITY = 0.86;
    const CAPTURE_MIN_JPEG_QUALITY = 0.62;

    function fitSize(width, height, maxLongEdge) {
      const w = Math.max(1, asInt(width, 1));
      const h = Math.max(1, asInt(height, 1));
      const longEdge = Math.max(w, h);
      if (longEdge <= maxLongEdge) return { width: w, height: h };
      const scale = maxLongEdge / longEdge;
      return {
        width: Math.max(1, Math.round(w * scale)),
        height: Math.max(1, Math.round(h * scale)),
      };
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve, reject) => {
        canvas.toBlob((blob) => {
          if (!blob) {
            reject(new Error("Failed to capture frame blob."));
            return;
          }
          resolve(blob);
        }, type, quality);
      });
    }

    function computeRoiContentMapping(srcW, srcH) {
      const baseAspect = ROI_BASE_WIDTH / ROI_BASE_HEIGHT;
      const srcAspect = srcW / srcH;
      const eps = 0.02; // tolerate small rounding differences
      let contentX = 0;
      let contentY = 0;
      let contentW = srcW;
      let contentH = srcH;
      let letterboxMode = "direct";
      if (Number.isFinite(srcAspect) && srcAspect > 0 && Math.abs(srcAspect - baseAspect) > eps) {
        if (srcAspect > baseAspect) {
          // wider than base -> crop horizontally (use centered 16:9 region)
          contentW = Math.max(1, Math.round(srcH * baseAspect));
          contentH = srcH;
          contentX = Math.max(0, Math.round((srcW - contentW) / 2));
          contentY = 0;
          letterboxMode = "crop_x";
        } else {
          // taller than base -> crop vertically
          contentW = srcW;
          contentH = Math.max(1, Math.round(srcW / baseAspect));
          contentX = 0;
          contentY = Math.max(0, Math.round((srcH - contentH) / 2));
          letterboxMode = "crop_y";
        }
      }

      const scaleX = contentW / ROI_BASE_WIDTH;
      const scaleY = contentH / ROI_BASE_HEIGHT;
      return {
        contentX,
        contentY,
        contentW,
        contentH,
        scaleX,
        scaleY,
        letterbox: {
          mode: letterboxMode,
          content_x: contentX,
          content_y: contentY,
          content_w: contentW,
          content_h: contentH,
          src_aspect: Math.round((srcAspect || 0) * 1000) / 1000,
          base_aspect: Math.round(baseAspect * 1000) / 1000,
        },
      };
    }

	    function scaledRoiRect(box, srcW, srcH) {
        // If the captured video is not the same aspect ratio as the ROI schema
        // (e.g. 21:9 ultrawide), the game UI is typically centered with extra
        // horizontal content. Map ROI coordinates onto the centered base-aspect
        // content rect instead of stretching across the full frame.
        const mapping = computeRoiContentMapping(srcW, srcH);
	      const scaleX = mapping.scaleX;
	      const scaleY = mapping.scaleY;
	      const cx = mapping.contentX + box.x * scaleX;
	      const cy = mapping.contentY + box.y * scaleY;
	      const bw = Math.max(1, Math.round(box.w * scaleX));
	      const bh = Math.max(1, Math.round(box.h * scaleY));

      const x1 = Math.max(0, Math.floor(cx - bw / 2));
      const y1 = Math.max(0, Math.floor(cy - bh / 2));
      const x2 = Math.min(srcW, Math.ceil(cx + bw / 2));
      const y2 = Math.min(srcH, Math.ceil(cy + bh / 2));

	      return {
	        x: x1,
	        y: y1,
	        w: Math.max(1, x2 - x1),
	        h: Math.max(1, y2 - y1),
          letterbox: mapping.letterbox,
	      };
	    }

	    async function captureMultiCropPayload() {
      if (!screenVideo.videoWidth || !screenVideo.videoHeight) {
        throw new Error("No screen frame available.");
      }
	      const srcW = screenVideo.videoWidth;
	      const srcH = screenVideo.videoHeight;
	      const rois = [];
        let letterbox = null;
	      for (const box of ROI_BOXES) {
	        const rect = scaledRoiRect(applyRoiOverrides(box, state.roiOverrides), srcW, srcH);
          if (!letterbox && rect.letterbox) {
            letterbox = rect.letterbox;
          }
	        if (rect.w < 8 || rect.h < 8) {
	          throw new Error(`ROI too small: ${box.label}`);
	        }
        const canvas = document.createElement("canvas");
        canvas.width = rect.w;
        canvas.height = rect.h;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          throw new Error("Canvas context unavailable.");
        }
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(
          screenVideo,
          rect.x,
          rect.y,
          rect.w,
          rect.h,
          0,
          0,
          rect.w,
          rect.h
        );
	        const blob = await canvasToBlob(canvas, "image/png");
	        rois.push({ label: box.label, rect, blob });
	      }
	      return { source_w: srcW, source_h: srcH, letterbox, rois };
	    }

    function captureVideoFrameBlob() {
      return new Promise(async (resolve, reject) => {
        if (!screenVideo.videoWidth || !screenVideo.videoHeight) {
          reject(new Error("No screen frame available."));
          return;
        }

        const srcW = screenVideo.videoWidth;
        const srcH = screenVideo.videoHeight;
        const resized = fitSize(srcW, srcH, CAPTURE_MAX_LONG_EDGE);

        const canvas = document.createElement("canvas");
        canvas.width = resized.width;
        canvas.height = resized.height;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Canvas context unavailable."));
          return;
        }
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
        ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);

        try {
          let quality = CAPTURE_INITIAL_JPEG_QUALITY;
          let blob = await canvasToBlob(canvas, "image/jpeg", quality);
          while (blob.size > CAPTURE_TARGET_BYTES && quality > CAPTURE_MIN_JPEG_QUALITY) {
            quality = Math.max(CAPTURE_MIN_JPEG_QUALITY, quality - 0.08);
            blob = await canvasToBlob(canvas, "image/jpeg", quality);
            if (quality <= CAPTURE_MIN_JPEG_QUALITY) break;
          }
          resolve({
            blob,
            source_w: srcW,
            source_h: srcH,
            upload_w: canvas.width,
            upload_h: canvas.height,
            jpeg_quality: quality,
          });
        } catch (err) {
          reject(err);
        }
      });
    }

    let roiAdjustSession = null;
    let roiAdjustDrag = null;

    function cloneJson(v) {
      try {
        return v == null ? v : JSON.parse(JSON.stringify(v));
      } catch (_err) {
        return null;
      }
    }

    function buildRoiDraftFromCurrent(overridesRaw) {
      const overrides = overridesRaw && typeof overridesRaw === "object" ? overridesRaw : {};
      const draft = {};
      for (const label of ROI_ADJUST_LABELS) {
        const def = ROI_BOXES.find((b) => b.label === label);
        if (!def) continue;
        const ov = overrides[label];
        const x = Number(ov && typeof ov === "object" ? ov.x : def.x);
        const y = Number(ov && typeof ov === "object" ? ov.y : def.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        draft[label] = {
          x: Math.max(0, Math.min(ROI_BASE_WIDTH, x)),
          y: Math.max(0, Math.min(ROI_BASE_HEIGHT, y)),
        };
      }
      return draft;
    }

    function computeContainRect(containerW, containerH, contentW, contentH) {
      const cw = Math.max(1, Number(containerW) || 1);
      const ch = Math.max(1, Number(containerH) || 1);
      const iw = Math.max(1, Number(contentW) || 1);
      const ih = Math.max(1, Number(contentH) || 1);
      const scale = Math.min(cw / iw, ch / ih);
      const w = iw * scale;
      const h = ih * scale;
      const x = (cw - w) / 2;
      const y = (ch - h) / 2;
      return { x, y, w, h, scale };
    }

    function setBoxStyle(el, rect) {
      if (!el || !rect) return;
      el.style.left = `${Math.round(rect.x)}px`;
      el.style.top = `${Math.round(rect.y)}px`;
      el.style.width = `${Math.max(1, Math.round(rect.w))}px`;
      el.style.height = `${Math.max(1, Math.round(rect.h))}px`;
    }

    function roiOverlayDeltaToBaseDelta(dxOverlay, dyOverlay, session) {
      if (!roiAdjustPreviewWrap || !session) return { dxBase: 0, dyBase: 0 };
      const wrapRect = roiAdjustPreviewWrap.getBoundingClientRect();
      const contain = computeContainRect(wrapRect.width, wrapRect.height, session.preview_w, session.preview_h);
      const mapping = computeRoiContentMapping(session.src_w, session.src_h);
      const cScale = Number(contain.scale) || 1;
      const pScale = Number(session.preview_scale) || 1;
      const denomX = cScale * pScale * (Number(mapping.scaleX) || 1);
      const denomY = cScale * pScale * (Number(mapping.scaleY) || 1);
      if (!Number.isFinite(denomX) || !Number.isFinite(denomY) || denomX === 0 || denomY === 0) {
        return { dxBase: 0, dyBase: 0 };
      }
      return { dxBase: dxOverlay / denomX, dyBase: dyOverlay / denomY };
    }

    function renderRoiAdjustOverlay() {
      if (!roiAdjustSession || !roiAdjustPreviewWrap) return;
      const session = roiAdjustSession;
      const wrapRect = roiAdjustPreviewWrap.getBoundingClientRect();
      const contain = computeContainRect(wrapRect.width, wrapRect.height, session.preview_w, session.preview_h);

      const srcW = session.src_w;
      const srcH = session.src_h;
      const pScale = session.preview_scale;

      function srcRectToOverlayRect(srcRect) {
        const px = srcRect.x * pScale;
        const py = srcRect.y * pScale;
        const pw = srcRect.w * pScale;
        const ph = srcRect.h * pScale;
        return {
          x: contain.x + px * contain.scale,
          y: contain.y + py * contain.scale,
          w: pw * contain.scale,
          h: ph * contain.scale,
        };
      }

      const optionRects = [];
      for (const label of ["option1", "option2", "option3", "option4"]) {
        const def = ROI_BOXES.find((b) => b.label === label);
        const xy = session.draft[label];
        if (!def || !xy) continue;
        optionRects.push(
          scaledRoiRect({ ...def, x: xy.x, y: xy.y }, srcW, srcH)
        );
      }

      if (optionRects.length === 4 && roiDragOptions) {
        const xmin = Math.min(...optionRects.map((r) => r.x));
        const ymin = Math.min(...optionRects.map((r) => r.y));
        const xmax = Math.max(...optionRects.map((r) => r.x + r.w));
        const ymax = Math.max(...optionRects.map((r) => r.y + r.h));
        const union = { x: xmin, y: ymin, w: xmax - xmin, h: ymax - ymin };
        const unionOverlay = srcRectToOverlayRect(union);
        setBoxStyle(roiDragOptions, unionOverlay);

        const sorted = optionRects.slice().sort((a, b) => a.x - b.x);
        const boundaries = sorted.slice(0, 3).map((r) => (r.x + r.w - union.x) * pScale * contain.scale);
        if (roiOptSep1) roiOptSep1.style.left = `${Math.round(boundaries[0] || 0)}px`;
        if (roiOptSep2) roiOptSep2.style.left = `${Math.round(boundaries[1] || 0)}px`;
        if (roiOptSep3) roiOptSep3.style.left = `${Math.round(boundaries[2] || 0)}px`;
      }

      const named = [
        ["possible", roiDragReroll],
        ["count", roiDragCount],
        ["cost", roiDragCost],
      ];
      for (const [label, el] of named) {
        const def = ROI_BOXES.find((b) => b.label === label);
        const xy = session.draft[label];
        if (!def || !xy || !el) continue;
        const rect = scaledRoiRect({ ...def, x: xy.x, y: xy.y }, srcW, srcH);
        setBoxStyle(el, srcRectToOverlayRect(rect));
      }
    }

    async function openRoiAdjustModal() {
      if (!roiAdjustBtn || !roiAdjustModal || !roiAdjustPreviewImg || !roiAdjustPreviewWrap) return;
      if (!screenVideo.videoWidth || !screenVideo.videoHeight) {
        alert("공유 화면 프레임이 없습니다. 화면 공유를 다시 시작해주세요.");
        return;
      }

      const srcW = screenVideo.videoWidth;
      const srcH = screenVideo.videoHeight;
      const resized = fitSize(srcW, srcH, 1600);

      const canvas = document.createElement("canvas");
      canvas.width = resized.width;
      canvas.height = resized.height;
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        alert("Canvas context unavailable.");
        return;
      }
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(screenVideo, 0, 0, canvas.width, canvas.height);

      let url = null;
      try {
        const blob = await canvasToBlob(canvas, "image/jpeg", 0.9);
        url = URL.createObjectURL(blob);
      } catch (_err) {
        alert("미리보기 캡처에 실패했습니다.");
        return;
      }

      const beforeRaw = cloneJson(state.roiOverrides) || null;
      roiAdjustSession = {
        before_raw: beforeRaw,
        draft: buildRoiDraftFromCurrent(beforeRaw),
        src_w: srcW,
        src_h: srcH,
        preview_w: resized.width,
        preview_h: resized.height,
        preview_scale: resized.width / srcW,
        preview_url: url,
      };

      roiAdjustPreviewImg.src = url;
      await new Promise((resolve) => {
        roiAdjustPreviewImg.onload = () => resolve(true);
        roiAdjustPreviewImg.onerror = () => resolve(false);
      });

      roiAdjustModal.classList.remove("hidden");
      roiAdjustModal.classList.add("flex");
      document.body.style.overflow = "hidden";

      requestAnimationFrame(() => {
        renderRoiAdjustOverlay();
      });
    }

    function closeRoiAdjustModal({ apply }) {
      if (!roiAdjustModal) return;
      const session = roiAdjustSession;
      roiAdjustDrag = null;
      roiAdjustSession = null;
      roiAdjustModal.classList.add("hidden");
      roiAdjustModal.classList.remove("flex");
      document.body.style.overflow = "";

      if (session && session.preview_url) {
        try {
          URL.revokeObjectURL(session.preview_url);
        } catch (_err) {
          // ignore
        }
      }

      if (!session) return;
      if (apply) {
        state.roiOverrides = session.draft;
        saveRoiOverridesToStorage(state.roiOverrides);
      } else {
        state.roiOverrides = session.before_raw;
      }
    }

    function onRoiDragPointerDown(ev) {
      const target = ev.currentTarget && ev.currentTarget.dataset ? ev.currentTarget.dataset.drag : null;
      if (!target || !roiAdjustSession) return;
      roiAdjustDrag = {
        target,
        pointerId: ev.pointerId,
        startX: ev.clientX,
        startY: ev.clientY,
        startDraft: cloneJson(roiAdjustSession.draft) || buildRoiDraftFromCurrent(null),
      };
      try {
        ev.currentTarget.setPointerCapture(ev.pointerId);
      } catch (_err) {
        // ignore
      }
      ev.preventDefault();
    }

    function onRoiDragPointerMove(ev) {
      if (!roiAdjustDrag || !roiAdjustSession) return;
      const dx = ev.clientX - roiAdjustDrag.startX;
      const dy = ev.clientY - roiAdjustDrag.startY;
      const { dxBase, dyBase } = roiOverlayDeltaToBaseDelta(dx, dy, roiAdjustSession);
      if (!Number.isFinite(dxBase) || !Number.isFinite(dyBase)) return;

      const next = cloneJson(roiAdjustDrag.startDraft) || {};
      const applyDelta = (label) => {
        if (!next[label]) return;
        next[label] = {
          x: Math.max(0, Math.min(ROI_BASE_WIDTH, Number(next[label].x) + dxBase)),
          y: Math.max(0, Math.min(ROI_BASE_HEIGHT, Number(next[label].y) + dyBase)),
        };
      };

      if (roiAdjustDrag.target === "options") {
        for (const label of ["option1", "option2", "option3", "option4"]) {
          applyDelta(label);
        }
      } else {
        applyDelta(roiAdjustDrag.target);
      }

      roiAdjustSession.draft = next;
      renderRoiAdjustOverlay();
      ev.preventDefault();
    }

    function onRoiDragPointerUp(_ev) {
      roiAdjustDrag = null;
    }

    function bindRoiAdjustControls() {
      if (!roiAdjustBtn || !roiAdjustModal) return;
      if (roiAdjustBtn.dataset.bound === "1") return;
      roiAdjustBtn.dataset.bound = "1";

      roiAdjustBtn.addEventListener("click", openRoiAdjustModal);

      if (roiAdjustCancelBtn) {
        roiAdjustCancelBtn.addEventListener("click", () => closeRoiAdjustModal({ apply: false }));
      }
      if (roiAdjustApplyBtn) {
        roiAdjustApplyBtn.addEventListener("click", () => closeRoiAdjustModal({ apply: true }));
      }

      // backdrop click -> cancel
      roiAdjustModal.addEventListener("click", (ev) => {
        if (ev.target === roiAdjustModal) {
          closeRoiAdjustModal({ apply: false });
        }
      });

      window.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape" && roiAdjustSession) {
          closeRoiAdjustModal({ apply: false });
        }
      });

      const draggables = [roiDragOptions, roiDragReroll, roiDragCount, roiDragCost].filter(Boolean);
      for (const el of draggables) {
        el.addEventListener("pointerdown", onRoiDragPointerDown);
        el.addEventListener("pointermove", onRoiDragPointerMove);
        el.addEventListener("pointerup", onRoiDragPointerUp);
        el.addEventListener("pointercancel", onRoiDragPointerUp);
      }

      if (roiAdjustPreviewWrap) {
        // Re-render on resize to keep overlay aligned.
        const ro = new ResizeObserver(() => {
          if (roiAdjustSession) renderRoiAdjustOverlay();
        });
        ro.observe(roiAdjustPreviewWrap);
      }
    }

		    async function analyzeCapture() {
		      if (!state.stream) {
		        return;
		      }
			      analyzeBtn.disabled = true;
			      state.successProb = null;
			      state.lastError = null;

				      try {
				        const tCapture0 = performance.now();
				        const formData = new FormData();
		            if (state.clientId) {
		              formData.append("client_id", String(state.clientId));
		            }
		            const manualOverrides = {};
		            if (state.uiOverride?.rerolls) {
		              const v = Math.max(0, Math.min(5, asInt(state.uiState?.rerolls, 0)));
		              formData.append("override_rerolls", String(v));
		              manualOverrides.rerolls = v;
		            }
		            if (state.uiOverride?.attempts_left) {
		              const v = Math.max(0, Math.min(9, asInt(state.uiState?.attempts_left, 0)));
		              formData.append("override_attempts_left", String(v));
		              manualOverrides.attempts_left = v;
		            }
		            if (state.uiOverride?.cost_state) {
		              const v = Math.max(-1, Math.min(1, asInt(state.uiState?.cost_state, 0)));
		              formData.append("override_cost_state", String(v));
		              manualOverrides.cost_state = v;
		            }
				        let captureMode = CAPTURE_PIPELINE;
				        let roiSchemaVersion = ROI_SCHEMA_VERSION;
				        let capture = null;
				        let blob = null;
		        let uploadBytes = 0;
		        let roiLabels = [];
		        let roiCount = 0;
		        let roiRects = [];
		        try {
		          capture = await captureMultiCropPayload();
		          const ts = Date.now();
		          for (const roi of capture.rois) {
		            formData.append(`roi_${roi.label}`, roi.blob, `${roi.label}_${ts}.png`);
		            uploadBytes += roi.blob?.size || 0;
		            roiLabels.push(roi.label);
		            roiRects.push({
		              label: roi.label,
		              w: roi.rect.w,
		              h: roi.rect.h,
		              bytes: roi.blob?.size || 0,
		            });
		          }
		          roiCount = capture.rois.length;
		        } catch (_multiCropErr) {
		          captureMode = FALLBACK_CAPTURE_PIPELINE;
		          roiSchemaVersion = FALLBACK_ROI_SCHEMA_VERSION;
		          capture = await captureVideoFrameBlob();
		          blob = capture.blob;
		          const fileName = `capture_${Date.now()}.jpg`;
		          formData.append("image", blob, fileName);
		          uploadBytes = blob?.size || 0;
		        }
			        const tCapture1 = performance.now();
			        formData.append("willpower", String(state.current.willpower));
	        formData.append("points", String(state.current.points));
	        formData.append("effect1_level", String(state.current.effect1_level));
	        formData.append("effect2_level", String(state.current.effect2_level));
			        formData.append("target_willpower", String(state.target.willpower));
			        formData.append("target_points", String(state.target.points));
		        formData.append("target_effect1_level", String(state.target.effect1_level));
		        formData.append("target_effect2_level", String(state.target.effect2_level));
	            formData.append("role", String(state.uiState?.role || "dealer"));
	            formData.append("gem_type", String(state.uiState?.gem_type || "stable"));
	            formData.append("roi_schema_version", roiSchemaVersion);
				        formData.append(
				          "client_debug",
				          JSON.stringify({
				            capture_ms: Math.round((tCapture1 - tCapture0) * 100) / 100,
		                capture_pipeline: captureMode,
		                roi_schema_version: roiSchemaVersion,
			            video_w: capture.source_w || screenVideo.videoWidth || null,
			            video_h: capture.source_h || screenVideo.videoHeight || null,
			            upload_w: capture.upload_w || null,
			            upload_h: capture.upload_h || null,
			            upload_bytes: uploadBytes || null,
			            jpeg_quality: capture.jpeg_quality || null,
			            letterbox: capture.letterbox || null,
                    roi_overrides: state.roiOverrides || null,
		                roi_count: roiCount,
		                roi_labels: roiLabels,
		                roi_rects: roiRects,
		                manual_overrides: manualOverrides,
			          })
			        );

			        const res = await fetch("/api/analyze", {
			          method: "POST",
			          body: formData,
		        });
		        const body1 = await res.json().catch(() => ({}));
		        if (!res.ok || !body1.ok) {
		          const detail =
		            body1?.detail || body1?.error || (Object.keys(body1 || {}).length ? JSON.stringify(body1) : "");
		          const suffix = detail ? `: ${detail}` : (res.statusText ? `: ${res.statusText}` : "");
		          throw new Error(`분석 실패 (HTTP ${res.status})${suffix}`);
		        }

		        let body = body1;
		        let didRetry = false;
		        const countText1 = body1?.ocr_result?.count;
		        const hasCount1 = typeof countText1 === "string" && countText1.includes("/");
		        if (captureMode === CAPTURE_PIPELINE && !hasCount1) {
		          didRetry = true;
		          const tRetry0 = performance.now();
			          const retryForm = new FormData();
			          if (state.clientId) {
			            retryForm.append("client_id", String(state.clientId));
			          }
			          if (state.uiOverride?.rerolls) {
			            retryForm.append("override_rerolls", String(Math.max(0, Math.min(5, asInt(state.uiState?.rerolls, 0)))));
			          }
			          if (state.uiOverride?.attempts_left) {
			            retryForm.append("override_attempts_left", String(Math.max(0, Math.min(9, asInt(state.uiState?.attempts_left, 0)))));
			          }
			          if (state.uiOverride?.cost_state) {
			            retryForm.append("override_cost_state", String(Math.max(-1, Math.min(1, asInt(state.uiState?.cost_state, 0)))));
			          }
			          const retryCapture = await captureVideoFrameBlob();
			          const retryBlob = retryCapture.blob;
			          const retryFileName = `capture_retry_${Date.now()}.jpg`;
			          retryForm.append("image", retryBlob, retryFileName);
		          const tRetry1 = performance.now();
		          retryForm.append("willpower", String(state.current.willpower));
		          retryForm.append("points", String(state.current.points));
		          retryForm.append("effect1_level", String(state.current.effect1_level));
		          retryForm.append("effect2_level", String(state.current.effect2_level));
		          retryForm.append("target_willpower", String(state.target.willpower));
		          retryForm.append("target_points", String(state.target.points));
		          retryForm.append("target_effect1_level", String(state.target.effect1_level));
		          retryForm.append("target_effect2_level", String(state.target.effect2_level));
		          retryForm.append("role", String(state.uiState?.role || "dealer"));
		          retryForm.append("gem_type", String(state.uiState?.gem_type || "stable"));
		          retryForm.append("roi_schema_version", FALLBACK_ROI_SCHEMA_VERSION);
			          retryForm.append(
			            "client_debug",
			            JSON.stringify({
			              capture_ms: Math.round((tRetry1 - tRetry0) * 100) / 100,
			              capture_pipeline: FALLBACK_CAPTURE_PIPELINE,
			              roi_schema_version: FALLBACK_ROI_SCHEMA_VERSION,
			              video_w: retryCapture.source_w || screenVideo.videoWidth || null,
			              video_h: retryCapture.source_h || screenVideo.videoHeight || null,
			              upload_w: retryCapture.upload_w || null,
			              upload_h: retryCapture.upload_h || null,
			              upload_bytes: retryBlob?.size || null,
			              jpeg_quality: retryCapture.jpeg_quality || null,
			              auto_retry: true,
			              retry_reason: "missing_count",
			              retry_of: body1?.record?.id || null,
			              first_capture_pipeline: captureMode,
			              first_roi_schema_version: roiSchemaVersion,
			              first_letterbox: capture?.letterbox || null,
                      roi_overrides: state.roiOverrides || null,
			              manual_overrides: manualOverrides,
			            })
			          );

		          const res2 = await fetch("/api/analyze", {
		            method: "POST",
		            body: retryForm,
		          });
		          const body2 = await res2.json().catch(() => ({}));
		          if (!res2.ok || !body2.ok) {
		            const detail =
		              body2?.detail || body2?.error || (Object.keys(body2 || {}).length ? JSON.stringify(body2) : "");
		            const suffix = detail ? `: ${detail}` : (res2.statusText ? `: ${res2.statusText}` : "");
		            throw new Error(`분석 재시도 실패 (HTTP ${res2.status})${suffix}`);
			          }
			          body = body2;
			        }

			        // If homography fails and the OCR result also looks empty, the shared
			        // screen is likely not the Lost Ark gem-processing UI (wrong window/tab).
			        // Avoid updating the UI with bogus "0/7" -> stop recommendations.
			        try {
			          const hom = body?.debug?.homography;
			          if (hom && hom.ok === false) {
			            const reason = String(hom.reason || "");
			            const optionsLen = Array.isArray(body.ui_state?.options) ? body.ui_state.options.length : 0;
			            const countText = body?.ocr_result?.count;
			            const costVal = body?.ocr_result?.cost;
			            const possVal = body?.ocr_result?.possible;
			            const looksEmpty =
			              optionsLen === 0 && (costVal == null || costVal === 0) && (possVal == null || possVal === 0);
			            const looksBadCount = typeof countText !== "string" || /^\s*0\s*\//.test(countText);
			            const fatalReasons = new Set([
			              "low_inliers",
			              "few_good_matches",
			              "no_target_features",
			              "homography_failed",
			              "missing_rois",
			            ]);
			            if (fatalReasons.has(reason) && looksEmpty && looksBadCount) {
			              state.lastError =
			                "공유한 화면에서 젬 가공 창을 찾지 못했습니다. 로스트아크(젬 가공 화면) 창을 선택해주세요.";
			              return;
			            }
			          }
			        } catch (_err) {
			          // Best-effort guard; never fail analyze because of this check.
			        }

			        state.lastResponse = body;
			        state.successProb = body.goal_success?.success_prob ?? null;
			        const gs = body.goal_success ?? null;
		        if (!gs) {
		          state.lastError = "서버 응답에 성공 확률(goal_success)이 없습니다. 서버를 재시작/업데이트해주세요.";
		        } else if (gs.success_prob == null) {
		          const reason = gs.reason ? String(gs.reason) : "unknown";
		          const errText = gs.error ? `: ${String(gs.error)}` : "";
		          state.lastError = `성공 확률 계산 실패 (${reason}${errText})`;
		        }
			        state.uiState = {
			          rerolls: asInt(body.ui_state?.rerolls, 0),
			          attempts_left: asInt(body.ui_state?.attempts_left, 0),
			          cost_state: asInt(body.ui_state?.cost_state, 0),
		          options: Array.isArray(body.ui_state?.options) ? body.ui_state.options : [],
	            role: String(body.ui_state?.role || state.uiState?.role || "dealer"),
	            gem_type: String(body.ui_state?.gem_type || state.uiState?.gem_type || "stable"),
		        };
	        state.ocrCount = body.ocr_result?.count || null;

	        const finalCountText = body?.ocr_result?.count;
	        const hasFinalCount = typeof finalCountText === "string" && finalCountText.includes("/");
	        if (!hasFinalCount && !state.lastError) {
	          const hint = didRetry
	            ? "전체 화면으로 재시도했지만 가공 횟수(count) 인식에 실패했습니다."
	            : "가공 횟수(count) 인식에 실패했습니다.";
	          state.lastError = `${hint} (21:9 화면공유/해상도/UI 스케일을 확인해주세요)`;
	        }
		      } catch (err) {
		        let msg = err && typeof err === "object" && "message" in err ? String(err.message || err) : String(err);
		        if (msg.includes("No screen frame available")) {
		          msg = "공유 화면 프레임이 없습니다. 화면 공유를 다시 시작해주세요.";
		        } else if (msg.includes("Failed to capture frame blob")) {
	          msg = "캡처 프레임 생성에 실패했습니다. 화면 공유를 다시 시작해주세요.";
	        } else if (msg.includes("Failed to fetch")) {
	          msg = "서버 연결에 실패했습니다. 서버가 실행 중인지 확인해주세요.";
	        }
	        state.lastError = msg;
	        console.error(err);
	      } finally {
	        analyzeBtn.disabled = false;
	        renderAll();
	      }
	    }

	    function applyOption(index) {
      const options = Array.isArray(state.uiState.options) ? state.uiState.options : [];
      const opt = options[index];
      if (!opt) return;

      const category = String(opt.category || "").toLowerCase();
      const value = asInt(opt.value, 0);

      if (category === "willpower") {
        state.current.willpower = clampStat(state.current.willpower + value);
      } else if (category === "points") {
        state.current.points = clampStat(state.current.points + value);
      } else if (category === "effect1") {
        if (value !== 0) {
          state.current.effect1_level = clampStat(state.current.effect1_level + value);
        }
      } else if (category === "effect2") {
        if (value !== 0) {
          state.current.effect2_level = clampStat(state.current.effect2_level + value);
        }
      } else if (category === "special") {
        if (isRerollOption(opt)) {
          const gain = Math.max(1, Math.min(2, Math.abs(value || 1)));
          state.uiState.rerolls = Math.max(0, asInt(state.uiState.rerolls, 0) + gain);
        } else if (isCostOption(opt)) {
          const delta = value >= 0 ? 1 : -1;
          state.uiState.cost_state = Math.max(-1, Math.min(1, asInt(state.uiState.cost_state, 0) + delta));
        }
      }

      if (asInt(state.uiState.attempts_left, 0) > 0) {
        state.uiState.attempts_left -= 1;
      }

      state.uiState.options = [];
      state.ocrCount = `${Math.max(0, asInt(state.uiState.attempts_left, 0))}`;
	      renderAll();
	    }

      function bindRoleGemControls() {
        if (roleSelect) {
          roleSelect.addEventListener("change", () => {
            const v = String(roleSelect.value || "").toLowerCase();
            state.uiState.role = v === "support" ? "support" : "dealer";
            renderAll();
          });
        }
        if (gemTypeSelect) {
          gemTypeSelect.addEventListener("change", () => {
            const v = String(gemTypeSelect.value || "").toLowerCase();
            if (v === "solid" || v === "immutable" || v === "stable") {
              state.uiState.gem_type = v;
            } else {
              state.uiState.gem_type = "stable";
            }
            renderAll();
          });
        }
      }

		    function bindStatControls() {
	      document.querySelectorAll("button[data-op]").forEach((btn) => {
	        btn.addEventListener("click", () => {
	          const key = btn.dataset.key;
	          const op = btn.dataset.op;
	          if (!key || !op) return;
	          const targetObj = op.includes("target") ? state.target : state.current;
	          const fallback = op.includes("target") ? 4 : 1;
	          const current = asInt(targetObj[key], fallback);
	          if (op === "inc-current" || op === "inc-target") {
	            targetObj[key] = clampStat(current + 1);
	          } else if (op === "dec-current" || op === "dec-target") {
	            targetObj[key] = clampStat(current - 1);
	          }
	          renderAll();
	        });
	      });

      document.querySelectorAll("input[data-input='current']").forEach((input) => {
        input.addEventListener("change", () => {
          const key = input.dataset.key;
          if (!key) return;
          state.current[key] = clampStat(input.value);
          renderAll();
        });
      });

      document.querySelectorAll("input[data-input='target']").forEach((input) => {
        input.addEventListener("change", () => {
          const key = input.dataset.key;
          if (!key) return;
          state.target[key] = clampStat(input.value);
          renderAll();
        });
      });
    }

		    shareStartBtn.addEventListener("click", startShare);
		    shareStopBtn.addEventListener("click", stopShare);
			    analyzeBtn.addEventListener("click", analyzeCapture);
			    resetBtn.addEventListener("click", resetGemState);
	    if (bugReportSendBtn) {
	      bugReportSendBtn.addEventListener("click", submitBugReport);
	    }
      if (letterSendBtn) {
        letterSendBtn.addEventListener("click", submitLetter);
      }

	        bindRoleGemControls();
			    bindStatControls();
	        bindSummaryAdjustControls();
          bindRoiAdjustControls();
	        renderNoticeItems(DEFAULT_NOTICE_ITEMS);
	        loadNotice();
        loadLetters();
        refreshServerStatus();
        setInterval(loadLetters, 30000);
        setInterval(refreshServerStatus, 30000);
		    setSharingUI(false);
		    renderAll();
  </script>
</body>
</html>
